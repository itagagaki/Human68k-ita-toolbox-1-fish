##########################################################################

                              DOCUMENTATION

                                   OF




                                ＦＩＳＨ

                               version 0.5




                                   BY

                             Itagaki Fumihiko


                              o ∞§__§§∞
                            ∞ §§     |§§
                          ∞§ §| 〇^〇 |§§
                         §§ § ;   ゝ  ;§ §
                        § § §  ;.""".;  § §
                           § §   ;;;;;   § §
                          § §            §

##########################################################################
■
■
■  目 次
■
■
■
■
■
■
■
■
■


■ 表紙  1

■ 目次  31

■ FISHの外観  121
　　FISHが動作する環境  135
　　FISHの動作モード  155
　　ログイン・シェルとしてのFISH  227
　　FISHの起動  263
　　FISHの終了  353

■ FISHの動作  391
　　1  行の入力  436
　　2  履歴置換  493
　　3  単語分け  751
　　4  履歴登録  772
　　5  別名展開  788
　　6  コマンドの構文  833
　　7  単一コマンドごとの処理  1078
　　　　7.1  入出力の切り替え  1088
　　　　7.2  コマンド名の解析  1199
　　　　7.3  引数に対する置換  1211
　　　　7.4  単一コマンドの検索  1226
　　　　　　※ ハッシュ機構  1295
　　　　7.5  単一コマンドの実行  1320
　　　　　　関数の実行  1323／組み込みコマンドの実行  1337／ディスク上のプ
　　　　　　ログラムの実行  1347／HUPAIR  1393／コマンドラインの壁  1409

■ 単語毎の置換  1471
　　変数置換  1485
　　コマンド置換  1655
　　組み合わせ展開  1672
　　ディレクトリ置換  1688
　　ファイル（ディレクトリ・エントリ）名展開  1711

■ 参照マニュアル  1771
　　エスケープとクオート  1785
　　パターン・マッチング  1803
　　式  1833
　　組み込みコマンド  2252
　　行入力機構  3120
　　特別なシェル変数  3462
　　特別な環境変数  3828
　　関連ファイル  3912
































■
■
■  F I S H の 外 観
■
■
■
■
■
■
■
■
■


■
■  FISHが動作する環境
■


　FISHは，Human68k version 2.02 上で動作します．これよりも古い版の
Human68k上での動作は保証しません．もっとも，いずれにしても無保証ですが．:-)

　オプションのデバイス・ドライバや常駐プログラムは一切必要ありません．
CONFIG.SYS が空っぽでもFISHは動作します．

　FISHはシフトJIS文字コード（X68000独自の拡張を含む）に対応しています．

　FISHが出力するほとんどのメッセージにもシフトJIS文字コードが使用されてい
ます．通常のASCII端末など，シフトJIS文字コードを表示することができない端末
でももちろん FISH を使用することができますが，FISH から出力されるエラー・
メッセージを読むことはできないでしょう．



■
■  FISHの動作モード
■


　FISHには次の２つの動作モードがあります．


　　● 標準入力モード

　　● スクリプト・モード


FISHは，原則的には，スクリプト・ファイル名が引数に与えられるとスクリプト・
モードで，そうでなければ標準入力モードで動作します．


■ 標準入力モード


　標準入力モードでは，標準入力から行を１行ずつ読みとって解釈・実行します．

　このモードはさらに


　　● インタラクティブ（対話的）・モード

　　● 非インタラクティブ・モード


の２つのモードに分かれます．原則的には，標準入力が端末であれば「インタラク
ティブ・モード」となり，それ以外では「非インタラクティブ・モード」となりま
すが，標準入力が端末でなくともFISHを -i オプションとともに起動すれば，FISH
はインタラクティブ・モードで動作します．

　インタラクティブ・モードでは行入力を促すプロンプトが出力されます．入力し
た行に文字‘#’はコメントとは見なされずにそのまま保存されます．入力した行
は履歴置換が施された後，履歴リストに登録されます．インタラクティブ・モード
で動作しているFISHは


　　　　ユーザ・インターフェースとしてのシェル


であると言えます．

　非インタラクティブ・モードではプロンプトは出力されず，履歴リストへの登録
も行われません．入力行に文字‘#’があると，そこから行末まではコメントであ
ると見なされます．


■ スクリプト・モード


　スクリプト・モードでは，最初にスクリプト・ファイル全体をメモリにロードし
てから解釈・実行します．スクリプト・モードで動作しているFISHは


　　　　プログラミング言語としてのシェル


であると言えます．

　スクリプト・モードでは，非インタラクティブ標準入力モードと同様，プロンプ
トは出力されず，履歴リストへの登録も行われません．入力行に文字‘#’がある
と，そこから行末まではコメントであると見なします．

　組み込みコマンド goto および onintr は，スクリプト・モードでのみ使用する
ことができます．



■
■  ログイン・シェルとしてのFISH
■


　FISHは，次の場合にログイン・シェルとして動作します．


　　●OSから直接起動されたとき．

　　　　これは，CONFIG.SYS に SHELL=A:\bin\fish.x のように記述したり，
　　　　Human68k のプロンプト # に対して A:\bin\fish のように入力すること
　　　　によって起動された場合です．

　　●親プロセスのメモリ管理ポインタ + 0x10a（親プロセスのプロセス管理ポイ
　　　ンタ＋0xfa）からの６バイトが 'login',0 であるとき．

　　　　これは，login.x（あるいは同様なコマンド）によって起動された場合で
　　　　す．

　　●フラグ引数 -l と共に起動されたとき．

　　　　これは将来廃止されるかも知れません．


ただし，フラグ引数 -c, -t, -n, -e, -f のいずれかが指定されている場合やフラ
グ以外の引数（すなわちスクリプトのパス名）がある場合にはFISHは非ログイン・
シェルとして動作します．

　ログイン・シェルは必ず標準入力モードで動作します．

　ログイン・シェルと非ログイン・シェルとの違いは起動時と終了時の動作にあり
ます．これについては，以下の『FISHの起動』と『FISHの終了』の項で説明します．



■
■  FISHの起動
■


　FISHの起動方法は次のとおりです．


　fish [ -bcefilnstvVxX ] [ 引数 ...  ]


フラグ引数には次のものがあります．


　-b      オプション解釈処理を強制的に中断し，以降の引数をオプション引数で
　　　　　ないものとします．このオプションは‘-’で始まるスクリプトを実行
　　　　　するために用いられます．

　-c      後に続く１つの引数をコマンドとして実行して終了します．残りの引数
　　　　　はシェル変数 argv にセットされます．

　-e      コマンドが異常終了したときや，0 以外の終了ステータスを返したとき
　　　　　にシェルを終了します．

　-f      ~/%fishrc を source しません．FISHを短時間で起動することができま
　　　　　す．シェル・スクリプトの先頭行には #! A:/bin/fish.x -f と記述し
　　　　　ておき，FISHを -f オプションつきで起動するべきです．これは高速化
　　　　　のためでもあり，シェル・スクリプトがシステムやユーザの環境の影響
　　　　　を受けることを防ぐためでもあります．

　-i      FISHの動作モードを「インタラクティブ・モード」とします．スクリプ
　　　　　ト・ファイルを指定する引数がなく，さらにFISHの標準入力が端末であ
　　　　　るときには，このフラグを指定しなくてもインタラクティブ・モードと
　　　　　なります．このフラグを指定すると，フラグ以外の引数があっても，そ
　　　　　れはスクリプト・ファイルの指定とは見なされません．

　-l      ログイン・シェルとして動作します．

　　　　　　　　　　このフラグ引数によってFISHをログイン・シェルとして動作
　　　　　　　　　　させることは好ましいことではありません．このフラグは将
　　　　　　　　　　来廃止されるかも知れません．

　-n      入力行を解析しますが，実行はしません．スクリプトの構文をチェック
　　　　　するために使用します．

　-s      FISHの動作モードを標準入力モードとします．スクリプト・ファイルを
　　　　　指定する引数がなければ，このフラグを指定しなくても標準入力モード
　　　　　となります．このフラグを指定すると，フラグ以外の引数があっても，
　　　　　それはスクリプト・ファイルの指定とは見なされません．

　-t      標準入力から１行を読み取って実行し，終了します．‘\’による行継
　　　　　続行は可能です．フラグ引数の処理後に残った引数はシェル変数 argv
　　　　　にセットされます．

　-v      シェル変数 verbose をセットします．

　-x      シェル変数 echo をセットします．

　-V      $%SYSROOT/etc/fishrc を実行する前にシェル変数 verbose をセットし
　　　　　ます．

　-X      $%SYSROOT/etc/fishrc を実行する前にシェル変数 echo をセットしま
　　　　　す．


-c，-i，-s，-t のいずれも指定されていないとき，フラグ引数の処理後に引数が
残っていれば，FISHはスクリプト・モードとなります．このとき，残った引数の最
初が実行するスクリプトのパス名となります．この引数は変数置換 "$0" によって
得ることができます．さらに残った引数はシェル変数 argv にセットされます．

上記以外の場合，FISHは標準入力モードとなり，残った引数はすべてシェル変数
argv にセットされます．このとき，標準入力が端末であれば，FISHはインタラク
ティブ・モードとなります．

　FISHは引数を解釈した後，ログイン・シェルであるならば，ユーザのホーム・ディ
レクトリに移動します．

　次に，スクリプト・ファイル $%SYSROOT/etc/fishrc があれば，それを source
（現在のシェルで実行）します．さらに，スクリプト・ファイル ~/%fishrc（シェ
ル変数 home にセットされているディレクトリ下のファイル %fishrc）があれば，
それを source します．ただし -f フラグが指定するとこれらは実行されません．

さらに，ログイン・シェルならば，スクリプト・ファイル ~/%login があれば次に
それを source します．

最後にFISHは，ファイル ~/%history があれば，その内容を読み込んで履歴リスト
に登録します．ただし -f フラグが指定するとこれは行われません．



■
■  FISHの終了
■


　FISHは EOF を入力したときに終了します．

　組み込みコマンド exit は強制的に入力を EOF としますので，組み込みコマン
ド exit によってシェルを終了させることができます．

　　　　　　　　　　　　より詳しくは，組み込みコマンド exit の説明を参照し
　　　　　　　　　　　　てください．

　FISHの入力が端末である場合には，端末から直接 EOF を入力することによって
もFISHを終了させることができます．ただしシェル変数 ignoreeof をセットして
おくと，端末からの EOF では終了しません．

　　　　　　　　　　　　シェル変数 usegets をセットしているときには端末か
　　　　　　　　　　　　ら EOF を入力することはできません．

　ログイン・シェルは組み込みコマンド logout によって即座に終了（すなわちロ
グアウト）することができます．ログイン・シェルが EOF を入力したときには，
組み込みコマンド logout が自動的に実行されます．FISHは本当にログアウトする
前に，スクリプト・ファイル ~/%logout があればそれを source し，次に，シェ
ル変数 savehist がセットされていれば，その値の行数分の履歴リストの最新のイ
ベントをファイル ~/%history に書き込みます．

　シェルの終了ステータスは，終了直前でのシェル変数 status の値です．










■
■
■  F I S H の 動 作
■
■
■
■
■
■
■
■
■


　FISHは基本的には次の順序で処理を行います．


　1   １行入力する

　2   履歴置換する

　3   行を単語に分解する

　4   単語リストを履歴リストに追加する

　5   別名を展開する

　6   コマンドの構文を解析する

　7   （行が通常のコマンド行ならば）各単一コマンドごとに次の順序で処理を行
　　　う

　　　1   入出力の切り替えを解析する

　　　2   コマンド名を解析する

　　　3   引数を置換・展開する

　　　4   コマンドを実行する


以下では，この順序にしたがって解説します．



■
■  1  行の入力
■


　FISHは，スクリプト・モードではスクリプト・ファイルから行を読み取ります．
ここで，１物理行の終わりは LF (0x0a) とし，LF の直前に CR (0x0d) がある場
合，その CR は無視します．FISHが LF を読み取る前にファイルが途切れた場合に
は，FISHはそれまでに読み取ったデータを行として入力せずに捨てます．

標準入力モードでは標準入力から行を読み取ります．標準入力が端末である場合，
通常はFISH独自の行入力機構で行の対話的編集を実現しています．この場合には，
行編集機能 accept-line を働かせた時点での編集行の内容が１物理行となります．
ただし EOF を入力したときには，その時点での編集行の先頭から EOF までの部分
が１物理行となります．

　　　　　　　　この行入力機構では DOSファンクション fgetc を用いているた
　　　　　　　　め，行編集中に CTRL+OPT.1+DEL キーや X68000 前面ボタンを押
　　　　　　　　しても，その後何かキーを押すまではそれらの機能は働きません．

標準入力モードであり，標準入力が端末であっても，シェル変数 usegets がセッ
トされているときには DOSファンクション gets を用いて行を読み取ります．この
場合の行入力方法はコンソール・ドライバによります．HISTORY.X 等の機能を利用
したいなどの場合にはシェル変数 usegets をセットしてください．

標準入力モードであり，標準入力が端末でない場合には，（インタラクティブ・モー
ドであっても）FISHは DOSファンクション fgets を用いて行を入力します．この
場合，標準的なシステムでは LF が１物理行の終わりとなり，CR は，それがどこ
に現われようとも削除されます．

　物理行の最後に‘\’を置くと，FISHはその物理行の末尾に１個のブランクを追
加し，さらに論理的な行を次の物理行に継続します．このとき，物理行の末尾が引
用符（‘'’‘"’，‘`’）による囲みの中にある場合には，ブランクとして１個
の復帰改行（CR+LF）を加えます．

　物理行の最後に‘\’が無くても，物理行の末尾が引用符による囲みの中にある
（すなわち，引用符による囲みが閉じていない）場合には，FISHはやはり論理的な
行を行を次の物理行に継続します．ただしこの場合には行末の改行は無視され，ブ
ランクも追加されません．行末の空白もそのまま保存されることに注意して下さい．

　インタラクティブ・モード以外のモードでは，物理行中の文字‘#’からその物
理行の終わりまではコメントであるとして削除されます．ただし，以下の‘#’に
この特別な意味はありません．


　　●引用符による囲みの中にある，あるいは‘\’でエスケープされている‘#’

　　●エスケープされていない‘!’，‘!{’，‘$’，‘${’の直後の‘#’


なお，コメントの削除は行継続を認識した後に行われますので，行継続の途中にも
コメントを挿入することができます．

　論理行の長さは4096バイトに制限されています．



■
■  2  履歴置換
■


　FISHは端末からの入力行を履歴リストに保存します（『4 履歴登録』参照）．履
歴置換は，履歴リストに保存されているイベントの一部または全体を現在の行に挿
入する機構です．履歴置換が行われたときには，置換後の行が端末にエコーされま
す．

　履歴置換を導く文字はシェル変数 histchars で設定することができます．シェ
ル変数 histchars がセットされていない場合のデフォルトは‘!’と‘^’です．
ここではデフォルトの設定で表記して解説します．

　以下の‘!’で始まる履歴置換は，行の任意の場所に置くことができます．


　!N
　!{N}

　　　N番のイベント．


　!-N
　!{-N}

　　　N個前のイベント．


　!str
　!{str}

　　　str で始まる最新のイベント．


　!?str?
　!{?str?}

　　　str を含む最新のイベント．str を省略すると，最近の !?str? 置換におけ
　　　る str または最近の :s/str1/str2/option/ 修飾（後で解説します）にお
　　　ける str1 のいずれか最近のものが使用されます．str は先頭の31バイトま
　　　でが有効です．字句解析上の不都合がなければ，str の後ろの‘?’は省略
　　　することができます．


　!!
　!{!}

　　　直前のイベント．


　!#
　!{#}

　　現在の行の先頭からこの置換（!#）の直前までの部分を履歴置換した結果．


■ 履歴置換文字のエスケープ


　履歴置換は行の分解・解釈よりも前に行われますので，履歴置換文字を引用符で
クオートすることはできません．履歴置換文字をエスケープするには‘\’を使用
してください．履歴置換文字をエスケープしている‘\’は，履歴置換後，履歴リ
ストに登録する前に削除されます．

　履歴置換文字の直後の文字が空白文字（スペース，復帰，改行，改頁，水平タブ，
垂直タブ），‘=’，‘~’，‘(’，‘\’のいずれかである場合には，その履歴置
換文字は履歴置換とは見なされず，通常の文字として保存されます．ですから，履
歴置換文字が‘!’であるとき，演算子‘!’，‘!=’，‘!~’ や，‘>! file’，
‘>>! file’などを記述する際に‘!’をエスケープする必要はありません．


■ {}による分離


　{ } は履歴置換をそのあとに続く文字と分離する役目を持ちます．例を示します．


　　　　　% echo foo
　　　　　% !ecd
　　　　　ecd: イベントが見当たりません
　　　　　% !{ec}d
　　　　　food


■ 単語選択子


　履歴イベントには単語分けがなされています．上記の !置換の直後に次の単語選
択子を１つだけ付加することによって，履歴イベントから一部の単語のみを取り出
すことができます．


　　:n    n番目の単語
　　:n-m  n番目から m番目までの単語
　　:-n   0番目（最初の単語）から n番目までの単語
　　:n-   n番目から最後の１つ前までの単語
　　:n*   n番目から最後までの単語
　　:*    1番目から最後までの単語


ここで，n および m は，


　　n     n番目の単語
　　^     1番目の単語
　　$     最後の単語
　　%     ?str? による検索で一致した単語


　!置換に { } による囲みを使用している場合，単語選択子は { } の中になけれ
ばなりません．


■ 修飾子


　上記の !置換の直後に，さらに次の修飾子を付加することができます．単語選択
子と共に使用する場合には単語選択子に続けて記述します．


　　:h

　　　　head．各単語について，パス名からドライブ名＋ディレクトリ部分を取り
　　　　出します．最後の / は含みません．単語にドライブ名＋ディレクトリ部
　　　　分がないならば，単語を元のまま保存します．


　　:t

　　　　tail．各単語について，パス名からファイル名部分（拡張子も含む）を取
　　　　り出します．


　　:r

　　　　root．各単語について，パス名から拡張子を除いた部分を取り出します．


　　:e

　　　　extention．各単語について，パス名からファイル名の拡張子部分を取り
　　　　出します．ただし拡張子の先頭の‘.’は含みません．


　　:d

　　　　drive．各単語について，パス名からドライブ名部分を取り出します．た
　　　　だしドライブ名の最後の‘:’は含みません．


　　:f

　　　　file．各単語について，パス名からドライブ名を除いた部分を取り出しま
　　　　す．


　　:s/str1/str2/option/

　　　　substitution．単語中の str1 を str2 に置き換えます．option が空な
　　　　らば，単語リスト中最初に現われる str1 のみが置換されます．option
　　　　として数値 n を記述すると，単語リスト中 n番目に現われる str1 のみ
　　　　を置換します．n は単語の番号ではないことに注意してください．オプショ
　　　　ンとして‘g’を記述すると単語リスト中に現われるすべての str1 を置
　　　　換します．

　　　　区切り文字‘/’の位置には，‘/’に限らず，‘}’を除く，シフトJIS文
　　　　字を含めた任意の文字を使用することができます．

　　　　str1 および str2 の中では，区切り文字として使った文字を‘\’でエス
　　　　ケープしなければなりません．str1 および str2 に文字‘\’そのものを
　　　　使いたいときには，その‘\’は‘\’でエスケープしなければなりません．

　　　　区切り文字として‘\’を使用しているときには‘\’をエスケープ文字と
　　　　して使用することはできません．

　　　　str1 が空である場合は，最近の :s 修飾における str1 または最近の
　　　　!?str? 置換における str のいずれか最近のものが使用されます．

　　　　str1 が‘^’である場合，それは各単語の先頭を意味します．例えば
　　　　:s/^/B:/g/ は，各単語にプリフィックス‘B:’を付加します．本来の文
　　　　字‘^’1文字を str1 として使いたい場合には‘\^’と記述しなければな
　　　　りません．

　　　　str1 が‘$’である場合，それは各単語の末尾を意味します．例えば
　　　　:s/$/.c/g/ は，各単語にサフィックス‘.c’を付加します．本来の文字
　　　　‘$’1文字を str1 として使いたい場合には‘\$’と記述しなければなり
　　　　ません．

　　　　str2 が空である場合には，str1 は空文字列に置き換えられる（すなわち
　　　　削除される）ことになります．

　　　　str2 が‘%’であれば，直前の :s 修飾における str2 が使用されます．
　　　　‘%’１文字を通常の意味で str2 として使いたい場合には‘\%’と記述
　　　　しなければなりません．

　　　　str2 の中の文字‘&’は，str1 そのものに置き換えられます．文字‘&’
　　　　そのものを使いたい場合には‘\’でエスケープしなければなりません．

　　　　字句解析上の不都合がなければ，:s 修飾の最後の‘/’は省略することが
　　　　でき，さらに，option をつけないならば str2 の後ろの‘/’も省略する
　　　　ことができます．

　　　　str1 は31バイト以下，str2 は63バイト以下でなければなりません．


　　:&option

　　　　以前に行った :s または :& での置換を再度行います．ここでの option
　　　　の意味は :s と同じです．


　　:p

　　　　履歴リストに登録するのみで，実行しません．


　複数の修飾子を連ねることができます．その場合，それらは左から右に順に処理
されます．

　!置換に { } による囲みを使用している場合には，修飾子は { } の中になけれ
ばなりません．


■ 省略記法


　単語選択子の最初の‘:’は，単語選択子が‘^’，‘$’，‘%’，‘*’，‘-’
のいずれかである場合には省略することができます．また，単語選択子かまたは修
飾子が続く‘!!’は‘!’と略記することができます．たとえば


　　　　　!!:$　　!!$　　!:$　　!$


はどれも同じです．


■ 簡便な修正


　入力行の最初の空白文字（スペース，復帰，改行，改頁，水平タブ，垂直タブ）
以外の文字が‘^’である場合，


　　　　^str1^str2^option^


という形式の履歴置換であると見なされます．これは


　　　　!!:s^str1^str2^option^


の省略形です．



■
■  3  単語分け
■


　FISHは履歴置換後の入力行を空白文字（スペース，復帰，改行，改頁，水平タブ，
垂直タブ）で単語に分解します．ただし例外として以下の綴りは前後に空白文字が
なくても１語と見なします．


　　　　　　<<<   <<=   <<    <=    <     >>=   >>    >=    >
　　　　　　&&    &=    &     ||    |=    |     ;     (     )


　空白文字や上記の特殊文字を単語の一部として記述するには，その文字をエスケー
プする必要があります．

　１語の長さは1024バイトに制限されています．



■
■  4  履歴登録
■


　インタラクティブ・モードでは，入力行を単語分けして単語リストとした後，単
語リストが空でなければそれを履歴リストに登録します．このとき，シェル変数
history に設定された期間内に１度も参照されなかったイベントは履歴リストから
削除されます．

　関数実行中は，関数内の行は履歴登録されません．

　履歴リストの内容を表示するには組み込みコマンド history を使用します．



■
■  5  別名展開
■


　入力行が単語分けされた後，その単語リストは後述のコマンドの構文にしたがっ
て解析され，各単一コマンドのコマンド名（最初の単語）が別名であるかどうかが
チェックされます．ただし‘\’を含むコマンド名は決して別名と見なされません．

　もしコマンド名が別名であるならば，その単語は新しいテキストに置き換えられ
ます．このとき，置き換わるテキストに対して再び履歴置換が行われます．ただし，
このときには !! は直前の履歴イベントではなく，元の単一コマンドの単語リスト
を参照します．したがって，たとえば !!:3 は３番目の引数を，!$ は元の単一コ
マンドの最後の引数を取り込み，!* は全引数を取り込みます．置き換わるテキス
トの中に履歴置換が一切なければ，置き換わるテキストの後ろに元の単一コマンド
の全引数が取り込まれます．

　行の中で１度でも別名置換が起こったならば，置換後の行の全体が再び単語分け
され，また再び別名置換処理が始まります．ただし，置換回数が20回を越えるとエ
ラーとして停止します．例外として，置き換わるテキストの最初の単語が別名と同
じである場合には，このコマンドに対して再び別名置換はしません．例えば


　　alias ls 'ls -CF'


を実行した後で


　　ls *.c


を入力すると，これは


　　ls -CF *.c


に置換されますが，この単一コマンドはこれ以上置換されません．

　シェル変数 noalias がセットされているときには別名置換は行われません．ま
た，関数内の行に対しては別名置換は行われません．



■
■  6  コマンドの構文
■


　別名置換後の行（単語リスト）は，次の２つに分類されます．


　　●通常のコマンド行

　　●特別な構文のキーワード行


以下，それぞれについて解説します．


■ 通常のコマンド行


　通常のコマンド行は，「単一コマンド」を任意に組み合わせたもの（複合コマン
ド）です．それぞれの単一コマンドは，１つ以上の単語が並んだものです．そのう
ち最初の単語はコマンド名を示します．残りの単語はコマンドに対する引数です．

　コマンドの組み合わせには以下のものがあります．ここで，C, C1, C2 は複合コ
マンドを意味します．


　( C )

　　　C をサブシェル（現在のシェルのコピー）で実行します．C が空であっても
　　　かまいません．


　C &

　　　C をサブシェルで実行します．C が空であってもかまいません．

　　　残念なことにバック・グラウンド実行はしません．:-(


　C1 ; C2

　　　C1 を実行し，それが終了したら次いで C2 を実行します．C1，C2 のどちら
　　　かあるいは両方が空であってもかまいません．


　C1 && C2

　　　C1 を実行し，その終了ステータスが 0 であった場合にのみ C2 を実行しま
　　　す．C1，C2 のどちらかあるいは両方が空であってはなりません．


　C1 || C2

　　　C1 を実行し，その終了ステータスが 0 でなかった場合にのみ C2 を実行し
　　　ます．C1，C2 のどちらかあるいは両方が空であってはなりません．


　C1 | C2

　　　C1 の標準出力を C2 の標準入力に接続した上で，まず C1 を実行し，それ
　　　が終了したら次いで C2 を実行します．C1，C2 のどちらかあるいは両方が
　　　空であってはなりません．


　C1 |& C2

　　　C1 の標準出力と標準エラー出力を C2 の標準入力に接続した上で，まず C1
　　　を実行し，それが終了したら次いで C2 を実行します．C1，C2 のどちらか
　　　あるいは両方が空であってはなりません．


これらの組み合わせの優先順位と結合方向は次のとおりです．


　　　　　　┌────┬────┬────────┐
　　　　　　│優先順位│結合方向│     区切子     │
　　　　　　├────┼────┼────────┤
　　　　　　│   高   │        │  ( )           │
　　　　　　│   ↑   │   →   │   &            │
　　　　　　│   ↓   │   →   │   ;   &&  ||   │
　　　　　　│   低   │   →   │   |   |&       │
　　　　　　└────┴────┴────────┘


いずれの場合にもコマンドは左から右の順に実行されます．


■ 特別な構文


　FISHには．通常のコマンド行とは別に，以下の特別な構文が用意されています．
これらの構文を構成するためのキーワードを含む行（キーワード行）は，通常の
コマンド行とは別に処理されます．原則として，キーワードはそれだけを１行と
しなければなりません．


　if ( <式> ) ...

　　　<式> の値が 0 でなければ ... を実行します．<式> の値は数値でなければ
　　　なりません．

　　　　　if行は ( ) の対がチェックされ，<式> 全体が変数置換されてから
　　　<式> が評価されます．

　　　　　式評価においては各一次子ごとにコマンド置換，組み合わせ展開，ディ
　　　レクトリ置換，ファイル名置換が行われます．



　if ( <式> ) then
　    ...
　else if ( <式２> ) then
　    ...
　...
　else
　    ...
　endif

　　　<式> の値が 0 でなければ，２行目から最初の else の直前までの行が実行
　　　され，その後 endif までの行は無視されます．

　　　<式> の値が 0 ならば最初の else までの行は無視されて <式２> が評価さ
　　　れます．<式２> の値が 0 でなければ，その次の行から次の else の直前ま
　　　での行が実行され，その後 endif までの行は無視されます．

　　　else if 文は任意の数だけ使用することができますし，１つもなくてもかま
　　　いません．

　　　<式>，<式２>，… のどれもが 0 であった場合には，最後の else の次の行
　　　から endif の直前までの行が実行されます．else の部分は endif の直前
　　　に１つだけ使用することができます．これもなくてもかまいません．

　　　endif は最後に１つだけ必要です．

　　　<式>，<式２>，… の値は数値でなければなりません．

　　　　　if行は ( ) の対がチェックされ，<式> 全体が変数置換されてから，
　　　<式> が評価されます．else if行においても同様です．

　　　　　式評価においては各一次子ごとにコマンド置換，組み合わせ展開，ディ
　　　レクトリ置換，ファイル名置換が行われます．



　switch ( <文字列> )
　case <パターン>:
　    ...
　...
　default:
　    ...
　endsw

　　　<文字列> にマッチする <パターン> を持つ case 文かまたは default ラベ
　　　ルが現われるまでの行を無視します．どちらも現われなかった場合には，
　　　endsw までが無視されることになります．

　　　<文字列> と <パターン> との比較については参照マニュアルの『パターン・
　　　マッチング』の項を参照してください．

　　　　　switch行はまず全体が変数置換されます．次に ( ) の対がチェックさ
　　　れ， <文字列> の部分がコマンド置換，組み合わせ展開，ディレクトリ置換，
　　　ファイル名置換の順に置換・展開されます．この結果は１つの単語でなけれ
　　　ばなりません．

　　　　　case行に対しては変数置換のみが行われます．



　foreach <変数名> ( <単語リスト> )
　    ...
　end

　　　<単語リスト> の要素（単語）ごとに end までの行を繰り返します．まず最
　　　初に <単語リスト> の最初（最も左）の単語をシェル変数 <変数名> にセッ
　　　トしてから end までの行を実行します．その後，繰り返しのたびに，<単語
　　　リスト> の次の単語がシェル変数 <変数名> にセットします．

　　　　　foreach行はまず全体が変数置換されます．次に <変数名> と ( ) の対
　　　がチェックされ，<単語リスト> の部分がコマンド置換，組み合わせ展開，
　　　ディレクトリ置換，ファイル名置換の順に置換・展開されます．<変数名>
　　　の部分には変数置換以外の置換・展開は行われません．



　while <式>
　    ...
　end

　　　<式> の値が 0 になるまで end までの行を繰り返します．<式> の値は数値
　　　でなければなりません．

　　　　　繰り返しのたびに <式> 全体が変数置換されてから <式> が評価されま
　　　す．式評価においては各一次子ごとにコマンド置換，組み合わせ展開，ディ
　　　レクトリ置換，ファイル名置換が行われます．



　<ラベル>:

　　　組み込みコマンド goto および onintr による分岐先を示します．<ラベル>
　　　は任意の文字からなる１つの単語です．長さに制限はありませんが，先頭の
　　　31バイトのみが有効であり，32バイト目以降は無視されます．

　　　　　同一スクリプト中に同じ綴りのラベルが複数ある場合には最初のものの
　　　みが認められ，それ以外は無視されます．

　　　　　<ラベル> は一切置換・展開されません．



　<関数名> ( ) {
　    ...
　}


　function <関数名> {
　    ...
　}


　function <関数名> ( ) {
　    ...
　}


　defun <関数名> {
　    ...
　}


　defun <関数名> ( ) {
　    ...
　}

　　　関数を定義します．<関数名> に対して変数置換が行われ，その結果の単語
　　　が，定義する関数名となります．変数置換の結果が１つの単語でなければな
　　　りません．関数名は31バイト以下の単語です．関数名の綴りは，ASCII英数
　　　字，‘_’（アンダースコア），シフトJISコードの組み合わせでなければな
　　　らず，さらに，関数名の先頭の文字は ASCII数字であってはなりません．

　　　関数定義時，関数内のコマンド行に対しては一切の置換は行われません．



■
■  7  単一コマンドごとの処理
■


　行が特別な構文のキーワード行でなく通常のコマンド行であるならば，行に含ま
れる単一のコマンドが構文にしたがって１つずつ実行されます．そのときどきにお
いて，各単一コマンドには以下の処理が以下の順序で行われます．


■  7.1  入出力の切り替え


　< file
　<! file

　　　コマンドの標準入力に file から入力します．file はファイルまたはデバ
　　　イスとして存在しているものでなければなりません．

　　　file がデバイスである場合，その入力ステータスが‘入力可’でなければ
　　　エラーとなりますが，‘!’をつけるかまたはシェル変数 forceio をセット
　　　しておくとそのチェックは行われません．


　> file
　>! file
　>& file
　>&! file

　　　コマンドの標準出力を（‘&’をつけた形式ではさらに標準エラー出力も）
　　　file に出力します．file が存在していない場合にはファイルとして新規に
　　　作成されます．file が存在するファイルである場合，そのファイルの以前
　　　の内容は失われます．

　　　file がデバイスである場合，そのデバイスの出力ステータスは‘出力可’
　　　でなければエラーとなりますが，‘!’をつけるかまたはシェル変数
　　　forceio をセットしておくとそのチェックは行われません．

　　　シェル変数 noclobber をセットしておくと，file がまだ存在していないファ
　　　イルであるかまたはデバイスでなければエラーになりますが，‘!’をつけ
　　　るとそのチェックは行われません．


　>> file
　>>! file
　>>& file
　>>&! file

　　　コマンドの標準出力を（‘&’をつけた形式ではさらに標準エラー出力も）
　　　file の終わりに追加出力します．file が存在していない場合にはファイル
　　　として新規に作成されます．

　　　file がデバイスである場合は‘>’と同じです．

　　　シェル変数 noclobber がセットしておくと，file が存在していなければエ
　　　ラーになりますが，‘!’をつけると，そのチェックは行われません．


　<< word

　　　ヒア・ドキュメント．シェルに対して続けて入力される行を，word のみの
　　　行が入力される直前までコマンドの標準入力に入力します．

　　　word がまったくエスケープされていないならば，行は予め変数置換とコマ
　　　ンド置換が行われてからコマンドに入力されます．この場合，変数置換とコ
　　　マンド置換を抑止するためには，‘$’や‘`’を‘\’でエスケープしてく
　　　ださい．ここでは‘'’と‘"’には特別な意味はありません．‘$’，‘`’，
　　　および‘\’をエスケープしている‘\’は削除され，それ以外の‘\’は保
　　　存されます．行に対するコマンド置換の結果は，ここでは最後の復帰改行が
　　　取り除かれる他はすべての文字が保存されます．

　　　word の一部または word 全体がエスケープされている場合には，行はその
　　　ままの形でコマンドに入力されます．

　　　word の綴りは任意ですが，FISHのキーワードと同じ綴りは避けるべきです．

　　　ヒア・ドキュメントを含むコマンドは１行に１つとするべきです．たとえば，


　　　　　cat -n << EOF ; cat -n << EOF
　　　　　　この行は最初の cat に入力されます．
　　　　　EOF
　　　　　　この行は２番目の cat に入力されます．
　　　　　EOF


　　　これは間違ってはいません．しかし，このような記述は勧められません．

　　　以下の例は間違っています．


　　　　　program && cat -n << EOF
　　　　　　ここからの行は，program の終了ステータスが 0 でなければヒア・
　　　　　　ドキュメントの内容であるとは認められないので，これは正しくあり
　　　　　　ません．
　　　　　EOF

　　　　　if ($foo) cat -n << EOF
　　　　　　これも同様です．$foo が 0 だと，ここからの行はヒア・ドキュメン
　　　　　　トの内容であるとは認められません．
　　　　　EOF


　　　ヒア・ドキュメントを含むコマンドと他のコマンドや制御文とを１つの行の
　　　中で組み合わせるべきではありません．


　<<< word

　　　ヒア・ストリング．word の末尾に復帰改行（CR+LF）を加えたものがコマン
　　　ドの標準入力に入力されます．


　単語 file や word は，予め，変数置換，コマンド置換，組み合わせ展開，ホー
ム・ディレクトリ置換，ファイル名展開の順序で置換・展開されます．この結果は
１つの単語でなければなりません．

　‘!’を使用するときには，それが履歴置換と見なされないよう，‘!’の後ろに
空白文字を置いて‘!’を１つの単語とする必要があります．


■  7.2  コマンド名の解析


　単一のコマンドから入出力切り替え部分を取り除いた後，単語リストの先頭の単
語がコマンド名と認識されます．残りの単語は，コマンドに対する引数リストと見
なされます．

　コマンド名を示す単語に対しては，引数リストとは別に，予め変数置換，コマン
ド置換，組み合わせ展開，ディレクトリ置換，ファイル名展開の順序で置換・展開
が行われます．この結果は１つの単語でなければなりません．


■  7.3  引数に対する置換


　まず，引数全体に対して変数置換が無条件に行われます．

　次に，コマンド置換，組み合わせ展開，ディレクトリ置換，ファイル名展開の順
序で置換・展開が行われます．ただし，以下の組み込みコマンドを実行する際には，
ここではこれらの置換・展開を行わず，各コマンドが実行時に個別に処理します．


　　　@         alias     bind      exit      printf    repeat
　　　set       setenv    time      unalias   undefun   unset
　　　unsetenv


■  7.4  単一コマンドの検索


　単一コマンドには次の３つの種類があります．


　　● 関数

　　● FISH組み込みコマンド

　　● ディスク上に置かれているプログラム


　FISHはまずコマンドが関数であるかどうかを調べます．検索しているコマンド名
に完全に一致する名前の関数が定義されていれば，FISHはその関数を実行します．

　コマンドが関数でなかったならばFISHは残る２つを調べますが，このときFISHは
この２つを厳密には区別しません．FISH組み込みコマンドは仮想的なディレクトリ
‘~~’にあるものとし，ディスク上のユーザ・プログラムと同様に検索します．

　コマンド名がドライブ／ディレクトリ名を含んでいるならば，FISHはそのドライ
ブ／ディレクトリを検索します．そうでなければ，シェル変数 path にセットされ
ている各ディレクトリを順繰りに検索し，最初に見つかったものを採用します．

　FISH組み込みコマンドは仮想的なディレクトリ‘~~’にあるということを思い出
してください．組み込みコマンドを実行するには‘~~/コマンド名’と書くか，ま
たはシェル変数 path の１要素として‘~~’をセットしておかなければなりません．

　検索を行う各々のディレクトリにおいては，まず，コマンド名のファイル名部分
（ドライブ名／ディレクトリ名を除いた部分）と完全に一致するファイルを検索し
ます．

　　　　　　　　　　検索ディレクトリが‘~~’である場合（組み込みコマンドを
　　　　　　　　　　検索しているとき）には，コマンド名の大文字と小文字は区
　　　　　　　　　　別されます．それ以外の場合（ディスク上に実在するディレ
　　　　　　　　　　クトリを検索しているとき）には，パス名の比較はＯＳに任
　　　　　　　　　　せていますので，パス名の大文字と小文字を区別するかどう
　　　　　　　　　　かはシステム毎に異なります．標準のシステムでは大文字と
　　　　　　　　　　小文字は区別されません．

ここで一致するファイルがなかったとき，次の２つの条件


　　●ディレクトリは‘~~’ではない

　　●コマンド名のファイル名部分に‘.’が含まれていない


が満たされているならば，以下の拡張子を持つファイルも検索対象として再び検索
します．

　　　　　　　　　　┌────┬────┐
　　　　　　　　　　│ 拡張子 │優先順位│
　　　　　　　　　　├────┼────┤
　　　　　　　　　　│  .R    │   高   │
　　　　　　　　　　│  .Z    │   ↑   │
　　　　　　　　　　│  .X    │   ↓   │
　　　　　　　　　　│  .BAT  │   低   │
　　　　　　　　　　└────┴────┘

　　　　　　　　　　これらの拡張子部分については大文字と小文字を区別せずに
　　　　　　　　　　照合し，優先順位が同じであれば先に検索されたファイルを
　　　　　　　　　　採用します．大文字と小文字を区別するシステムでは注意が
　　　　　　　　　　必要です．

それでもコマンドが見つからなければ，そのディレクトリでコマンドを見つけるこ
とを諦めます．


※ ハッシュ機構


　path に従って検索を行う際には，内部のハッシュ表を利用して，コマンドが存
在する可能性のないディレクトリでは検索を行いません．このハッシュ機構によっ
て，シェル変数 path に多数のディレクトリがセットされている場合のコマンドの
検索を高速化しています．

　FISHに対して -c オプションも -t オプションも指定されていなければ，FISHは
起動時にシェル変数 path にセットされているディレクトリのうち完全パスである
ディレクトリ内のエントリを内部のハッシュ表にハッシュします．また，シェル変
数 path や環境変数 path を再設定したときにもハッシュ表は自動的に更新されま
す．ですから普段はハッシュ表の状態について気にかける必要はありません．しか
し，新しいコマンド・ファイルをシェル変数 path のディレクトリに置いた後には，
組み込みコマンド rehash を実行してハッシュ表を更新しないと，そのコマンドは
検索されない可能性があります．

　検索するディレクトリが完全パスでない場合には，そのディレクトリは必ず検索
します．

　ハッシュ機構を組み込みコマンド unhash によってオフにしている場合や，-cオ
プションまたは -tオプションが指定されていてハッシュ表が作成されていない場
合には，どのディレクトリも必ず検索します．


■  7.5  単一コマンドの実行


● 関数の実行


　関数は現在のシェルで実行されます．ただし，コマンドの出力がパイプやファイ
ルにリダイレクトされているときにはサブシェルで実行されます．

　関数への引数はシェル変数 argv に置かれます．関数の実行を終了すると argv
の値は元に戻ります．関数内では $0 は関数名に置換されます．

　関数内の行は別名置換されません。

　関数の終了ステータスは、関数終了時のシェル変数 status の値です。


● 組み込みコマンドの実行


　組み込みコマンドを実行する際には，実行する直前にシェル変数 status に 0
がセットされ，その後，組み込みコマンド実行時にエラーがあったときにのみ，シェ
ル変数に 1 がセットされます．ですから，set status=5 あるいは @ status=5 を
実行後の status の値は 0 ではなく 5 です．また，exit 5 を実行後の status
の値も，やはり 5 です．


● ディスク上のプログラムの実行


　見つかったコマンド・ファイルの拡張子が‘.R’，‘.Z’，‘.X’のいずれか（
大文字と小文字は区別されません）である場合には，FISHはそのファイルを実行形
式バイナリ・ファイルと見なして直接 exec します．コマンドに対する引数リスト
は HUPAIR（後で解説します）に従ってエンコードされてコマンドラインに置かれ
ます．

　拡張子が‘.BAT’（大文字と小文字は区別されません）である場合にはシェル変
数 batshell にセットされているシェル・プログラムを exec します．このとき
exec するシェル・プログラムに対して渡される引数リストの第一引数は，本来の
コマンドのパス名の‘/’を‘\’に替えた単語，第二引数以降は，本来のコマンド
に対する引数リストとなります．これらは HUPAIR に従ってエンコードされてコマ
ンドラインに置かれます．

　コマンド・ファイルの拡張子がこれら以外である場合には，コマンド・ファイル
の内容の先頭が‘#$’または‘#!’ならば，このファイルをスクリプトであると見
なして実行します．そうでなければ実行せずにエラーとします．

　コマンド・ファイルの内容の先頭が‘#!’であり，その同一行に，それに続けて
シェル・プログラムのパス名が記述されているならば，そのシェル・プログラムを
exec します．シェル・プログラムのパス名は空白文字（スペース，復帰，改頁，
水平タブ，垂直タブ）を区切り文字として切り出され，前後の空白は無視されます．
シェル・プログラムのパス名の直後から改行（LF）の直前までの部分は，シェル・
プログラムに対して最初に渡すべき引数リストを HUPAIR に従ってエンコードした
文字列と見なされ，シェル・プログラムに対して渡されるコマンドラインの先頭に
置かれます．これに続いて本来のコマンドのパス名が，さらに続いて本来のコマン
ドに対する引数リストが，HUPAIR に従ってエンコードされてコマンドラインに追
加されます．

　コマンド・ファイルの先頭の‘#!’以降改行までが空または空白文字だけである
場合，あるいはコマンド・ファイルの内容の先頭が‘#$’である場合には，シェル
変数 shell にセットされているシェル・プログラムを exec します．このとき
exec するシェル・プログラムに対して渡される引数リストの第一引数は，本来の
コマンドのパス名の‘/’を‘\’に替えた単語，第二引数以降は，本来のコマンド
に対する引数リストとなります．これらは HUPAIR に従ってエンコードされてコマ
ンドラインに置かれます．

　exec するプログラムに対してFISHの環境変数の完全な複製を渡します．この環
境エリアの余白はシェル変数 envmargin で制御することができます．

　ディスク上のプログラムを exec すると，その実行が終わる度にその終了ステー
タスがシェル変数 status にセットされます．


● HUPAIR

　ディスク上のプログラムを exec する際，そのコマンドラインには，すでに述べ
たとおり，コマンドに対する引数リスト（単語並び）を HUPAIR に従ってエンコー
ドした文字列をセットしてコマンドに渡します．

　HUPAIR とは Human68k User Program Argument Interface Regurations の略で
す．つまり，Human68k 上のユーザ・プログラム間で引数リストを受け渡す方法を
規定するものです．詳細は，資料 HUPAIR.DOC を参照してください．

　起動するユーザ・プログラムが HUPAIR デコーダを組み込んだ『HUPAIR適合プロ
グラム』であるなら，FISH からの引数リストは安全確実にコマンドに伝わります．
そうでなくとも通常は問題が起こらないように考慮した設計が HUPAIR には為され
ていますが，保証の限りではありません．


● コマンドラインの壁


　Human68k ではコマンドラインにセットする文字列の長さは0バイト以上255バイ
ト以下とされています．現実には255バイトを超える文字列をセットすることは可
能なのですが，255バイトに制限されていることを前提として書かれたユーザ・プ
ログラムも少なくなく，その中には，渡されたコマンドラインの文字列の長さが
255バイトを超えていると重大な障害を引き起こすものもあるために，どのプログ
ラムにも無条件に255バイトを超える文字列を渡すのは危険です．

　FISHは，ディスク上のプログラムを実行しようとするとき，コマンドラインの文
字列が255バイトを超えている場合には，まずプログラムを一旦ロードし，それが
HUPAIR適合プログラムであるかどうかを調べます．HUPAIR適合プログラムであれば
255バイトを超える文字列を問題なく受け取るはずですから，そのままの引数を渡
して実行します．

　プログラムが HUPAIR適合プログラムでないならば，FISHはシェル変数 hugearg
の設定に従って対処します．

　set hugearg=force としておくと，そのままの引数を渡して実行します．

　set hugearg=indirect としておくと，引数を一時ファイルに書き込み，プログ
ラムには引数として‘-+-+-<ファイル名>’を渡して実行します．<ファイル名> の
ディレクトリは‘\’で区切られています．

　set hugearg=(indirect <文字列>) としておくと，‘-+-+-’の代わりに <文字
列> を使います．

　以上のどれにも当てはまらない場合にはエラーとして実行を諦めます．

































■
■
■  単 語 ご と の 置 換
■
■
■
■
■
■
■
■
■


■
■  変数置換
■


　変数置換は‘"’によるクオートの中でも行われます．‘'’によるクオートの中
では行われません．‘`’によるクオート（コマンド置換）の中の変数置換はサブ
シェルによって行われることになります．


　$var
　${var}
　$@var
　$@{var}
　$%var
　$%{var}

　　　‘@’をつけた形式ではシェル変数 var の，‘%’をつけた形式では環境変
　　　数 var の値．‘@’も‘%’もつけない形式では，まずシェル変数が調べら
　　　れ，セットされていなければ環境変数が調べられます．


　$var[index]
　${var[index]}
　$@var[index]
　$@{var[index]}
　$%var[index]
　$%{var[index]}

　　　‘@’をつけた形式ではシェル変数 var の，‘%’をつけた形式では環境変
　　　数 var の index 番目の値．‘@’も‘%’もつけない形式では，まずシェル
　　　変数が調べられ，セットされていなければ環境変数が調べられます．


　$#var
　${#var}
　$@#var
　$@{#var}
　$%#var
　$%{#var}

　　　‘@’をつけた形式ではシェル変数 var の単語数．‘%’をつけた形式では
　　　環境変数 var の単語数（ただし環境変数の単語数は常に 1 となります）．
　　　‘@’も‘%’もつけない形式では，まずシェル変数が調べられ，セットされ
　　　ていなければ環境変数が調べられます．


　$?var
　${?var}
　$@?var
　$@{?var}
　$%?var
　$%{?var}

　　　‘@’をつけた形式ではシェル変数 var が，‘%’をつけた形式では環境変
　　　数 var がセットされていれば 1．そうでなければ 0．‘@’も‘%’もつけ
　　　ない形式では，まずシェル変数が調べられ，セットされていなければ環境変
　　　数が調べられます．


　$*
　${*}

　　　$argv と同じ．


　$i
　${i}

　　　i は 0 から 9 までの範囲の数字です．これは $argv[i] と同じ意味ですが，
　　　i がシェル変数 argv の単語数より大きくてもエラーにはならずに空文字列
　　　となります．


　$0
　${0}

　　　スクリプト実行中はスクリプトのファイル名．関数実行中は関数名．


　$<
　${<}

　　　標準入力から入力される１物理行に置換されます．入力行は１つの単語とし
　　　て扱われ，それ以上の解釈はされません．


　$$
　${$}

　　　シェル番号（10進表記）．先祖プロセスにFISHが１つもない状態から起動さ
　　　れたFISHのシェル番号は 1 となり，以後FISHを起動する度に，そのシェル
　　　番号は 1 ずつ増加します．サブシェルのシェル番号は親シェルと同一です．


　$,
　${,}

　　　0 から 32767 までの範囲の整数の擬似一様乱数．（10進表記）


■ index


　　　n　     n番目の単語
　　　n-m     n番目から m番目までの単語
　　　-n      1番目（最初の単語）から n番目までの単語
　　　n-      n番目から最後までの単語
　　　n*      n番目から最後までの単語
　　　*       1番目から最後までの単語（全単語）


　たとえば $p[$q] のように，index にも変数置換を使用することができます．


■ 修飾子


　上記の変数置換の直後に，次の修飾子を付加することができます．複数の修飾子
を連ねることができ，それらは左から右に順に処理されます．変数置換に { } に
よる囲みを使用している場合には，修飾子は { } の中になければなりません．


　　:h
　　:t
　　:r
　　:e
　　:d
　　:f
　　:s/str1/str2/option/
　　:&option

　　　　履歴置換の修飾と同じです．


　　:q

　　　単語数を保存する形で各単語をクオートします．


　　:x

　　　各単語をさらに単語に分解した上で，それぞれの単語をクオートします．


■ {}による分離


　{ } は変数置換をそのあとに続く文字と分離する役目を持ちます．例を示します．

　　　　　% set foo=bar foo2=quux
　　　　　% echo $foo2
　　　　　quux
　　　　　% echo ${foo}2
　　　　　bar2

　また，次の例のように‘&’などの特殊な文字を含む修飾子を付加する際にも変
数置換を { } で囲む必要があります．

　　　　　% set foo='fish is fun'
　　　　　% echo $foo
　　　　　fish is fun
　　　　　% echo $foo:s/fish/&ing/
　　　　　is fun
　　　　　ing/: コマンドが見当たりません
　　　　　% echo ${foo:s/fish/&ing/}
　　　　　fishing is fun



■
■  コマンド置換
■


　`command` は command をサブシェル（現在のシェルのコピー）で実行し，標準
出力に出力された文字列に置き換えます．このとき，通常は，空白文字（スペース，
復帰，改行，改頁，水平タブ，垂直タブ）で別々の単語に分解され，空の単語は破
棄されます．
　コマンド置換が‘"’によるクオートの中にある場合には，単語の分解は改行ま
たは復帰改行だけで行われ，その他の空白文字は保存されます．いずれの場合にも，
最後の復帰改行だけは取り除かれ，新しい単語を生成しません．

　‘'’によるクオートの中では，このコマンド置換は行われません．



■
■  組み合わせ展開
■


　a{b,c,d}e は abe ace ade に展開され，a{b,c}{d,e,f}g は abdg abeg abfg
acdg aceg acfg に展開されます．左右の関係は保存されます．特殊な場合として，
‘{’，‘}’，および‘{}’はそのまま保存されます．

　シェル変数 noglob がセットされているときには，この組み合わせ展開は行われ
ません．また，‘"’または‘'’によるクオートの中ではこの組み合わせ展開は行
われません．‘`’によるクオート（コマンド置換）の中の組み合わせ展開はサブ
シェルによって行われることになります．



■
■  ディレクトリ置換
■


　単語が‘~’であるかまたは単語の先頭が‘~/’である場合，先頭の‘~’はユー
ザのホーム・ディレクトリ（シェル変数 home の値）に置き換えられます．また，
単語が‘~user’であるかまたは単語の先頭が‘~user/’（user は１文字以上の
ASCII 英数字の綴り）である場合，先頭の‘~user’はユーザ user のホーム・ディ
レクトリに置き換えられます．FISHはユーザ user のホーム・ディレクトリをシス
テム・ファイル $%SYSROOT/etc/passwd から得ます．

　単語が‘=n’であるかまたは単語の先頭が‘=n/’（n は１桁以上の10進数）で
あるとき，先頭の‘=n’はディレクトリ・スタックの n番目の要素に置き換えられ
ます．0番目の要素はカレント・ディレクトリです．

　シェル変数 noglob がセットされているときには，このディレクトリ置換は行わ
れません．また，‘"’または‘'’によるクオートの中では，このディレクトリ置
換は行われません．‘`’によるクオート（コマンド置換）の中のディレクトリ置
換はサブシェルによって行われることになります．



■
■  ファイル（ディレクトリ・エントリ）名展開
■


　パターン・マッチングによりファイル（ディレクトリ・エントリ）名展開が行わ
れます（『パターン・マッチング』参照）．ただしボリューム・ラベルは展開しま
せん．

　ディレクトリの区切り文字としては通常‘/’を用いますが，‘\’をエスケープ
した形である‘\\’および‘/’をエスケープした形である‘\/’もディレクトリ
の区切りとして認められます．

　パス名のどの部分にもパターン・マッチングのメタ・キャラクタを使用すること
ができますが，ドライブ名の‘:’，ディレクトリの区切りの‘/’（もしくは
‘\\’，‘\/’）は明示的に記述しなければなりません．また，‘.’で始まるエ
ントリは通常は展開されませんので，それを展開したい場合には最初の‘.’は明
示的に記述しなければなりません．

　単語をファイル名展開した結果の単語リストは文字コード順にソートされていま
す．

　コマンドの引数にファイル名展開があるとき，マッチするファイルが１つも存在
していなければエラーとなりますが，ファイル名展開を含む引数のすべてがマッチ
しなければならないわけではありません．

　シェル変数 nonomatch がセットされている場合には，マッチするファイル名が
１つも存在していない場合にもエラーとせず，展開前の単語をそのまま保存します．

　ファイル名展開は通常，ファイル名の ASCII英大文字と小文字を区別しますが，
シェル変数 ciglob がセットされている場合には区別しません．ただしこの場合に
も展開結果は大文字と小文字を区別してソートします．

　シェル変数 noglob がセットされているときには，このファイル名展開は行われ
ません．また，‘"’または‘'’によるクオートの中では，このファイル名展開は
行われません．‘`’によるクオート（コマンド置換）の中のファイル名展開は，
サブシェルによって行われることになります．























■
■
■  参 照 マ ニ ュ ア ル
■
■
■
■
■
■
■
■
■


■
■  エスケープとクオート
■


　\c            文字 c をエスケープします．

　'string'      string をクオートします．

　"string"      string をクオートしますが，string に対して変数置換とコマン
　　　　　　　　ド置換は行われます．

　`command`     command をサブシェル（現在のシェルのコピー）で実行し，標準
　　　　　　　　出力に出力された文字列に置き換えます．（コマンド置換）
　　　　　　　　command に対する置換はサブシェル側で行われます．



■
■  パターン・マッチング
■


　ここではファイル名展開，case文，パターン比較演算式（=~ および !~），組み
込みコマンド unalias，undefun，unset，およびシェル変数 notexportpath にお
いて行われるパターン・マッチングについて説明します．

　パターンのメタ・キャラクタには次のものがあります．


　　*         ０個以上の任意の文字とマッチします
　　?         任意の１文字とマッチします
　　[list]    list 中の１文字とマッチします
　　[^list]   list に含まれない１文字とマッチします


list 中では‘-’は範囲を表わします．lower-upper は，文字コードが，文字
lower と文字 upper の間にある任意の１文字とマッチすることになります．

list 中でも文字‘\’は続く文字をエスケープします．エスケープされていない
‘[’または‘[^’の直後では‘-’と‘]’は特別な意味を持ちません．また，特
別な意味を持つ‘-’に続く‘-’と‘]’は特別な意味を持ちません．

　なお，マルチバイト文字も１文字と見なします．マルチバイト文字は，どの１バ
イト文字よりも大きいものとします．



■
■  式
■


　ここでは if文，while文，組み込みコマンド @，exit，printf，return におけ
る「式」について解説します．

　式は，予め全体的に変数置換されてから評価されます．さらに，キーワードや演
算子を除く各トークンは，一次子が評価されるとき個別にコマンド置換，組み合わ
せ展開，ディレクトリ置換，ファイル名展開の順序で置換・展開されます．ただし，
演算子 =~ および !~ の直後のトークンが通常の単語である場合，その単語に対し
ては一切の置換・展開は行われません．

　式の演算子は１つの単語として独立していなければなりません．演算子の前後に
は必ず空白文字（スペース，復帰，改行，改頁，水平タブ，垂直タブ）を置くよう
にしてください．例外として，以下のトークンはコマンドの構文記号として自動的
に１つの単語と見なされるので，空白で区切る必要はありません．


　　　　<<    <     >>    >     &&    &     ||    |     (     )


これらの演算子を含む式は，演算子がコマンドの構文記号と見なされぬよう ( )
で囲まなければなりません．

　FISH は式の各項を文字列として評価します．数値演算式においては，各項の文
字列を一旦数値に変換してから演算を行い，その結果を必要最小桁数の10進表記文
字列に変換します．このとき，値が負数であれば文字列の先頭には符号‘-’が付
き，正数であれば符号は付きません．

　数値演算は符号つき32ビットの整数型として行います．オーバーフローおよびア
ンダーフローは無視します．0 による除算および剰余算はエラーとします．


■ 文字列から数値への変換規則


　式の値は文字列として表現され，数値が要求される項においては以下の規則によっ
て数値に変換されます．このときオーバーフローは無視されます．


　d...

　　　10進数（d は‘0’から‘9’までのいずれかの文字）


　0d...

　　　8進数（d は‘0’から‘7’までのいずれかの文字）


　0xd...
　0Xd...

　　　16進数（d は‘0’から‘9’まで，‘A’から‘F’まで，‘a’から‘f’ま
　　　でのいずれかの文字）


　これらの表記の前には符号‘-’あるいは‘+’が認められます．もちろん，正数
ならば符号は不要です．


■ 一次式


　以下に各一次式について解説します．


　-d file

　　file がディレクトリ・エントリとして存在し，かつ，ディレクトリ属性が ON
　　ならば‘1’．そうでなければ‘0’．


　-e file

　　file がディレクトリ・エントリとして存在するならば‘1’．そうでなけれ
　　ば‘0’．


　-f file

　　file がディレクトリ・エントリとして存在し，かつ，通常のファイルならば
　　‘1’．そうでなければ‘0’．


　-w file

　　file がディレクトリ・エントリとして存在し，かつ，読み込み専用属性が
　　OFF ならば‘1’．そうでなければ‘0’．


　-z file

　　file がディレクトリ・エントリとして存在し，かつ，サイズが 0 ならば
　　‘1’．そうでなければ‘0’．


　-c name

　　name がオープン可能なキャラクタ・デバイスであるならば‘1’．そうでなけ
　　れば‘0’．


　-b name

　　name がオープン可能なブロック・デバイスであるならば‘1’．そうでなけれ
　　ば‘0’．


　-i name

　　name がオープン可能かつ入力可能なデバイスであるならば‘1’．そうでなけ
　　れば‘0’．


　-o name

　　name がオープン可能かつ出力可能なデバイスであるならば‘1’．そうでなけ
　　れば‘0’．


　-a file

　　file がディレクトリ・エントリとして存在し，且，アーカイブ属性が ON な
　　らば‘1’．そうでなければ‘0’．


　-h file

　　file がディレクトリ・エントリとして存在し，且，秘匿属性が ON ならば
　　‘1’．そうでなければ‘0’．


　-s file

　　file がディレクトリ・エントリとして存在し，且，システム属性が ON なら
　　ば‘1’．そうでなければ‘0’．


　-v file

　　file がディレクトリ・エントリとして存在し，且，ボリューム・ラベル属性
　　が ON ならば‘1’．そうでなければ‘0’．


　-t n

　　シェルのファイル・デスクリプタ n がコンソールならば‘1’．そうでなけれ
　　ば‘0’．


　sizeof file

　　ディレクトリ・エントリ file のサイズの10進表記文字列．file が存在しな
　　いならば‘0’．


　timeof file

　　ディレクトリ・エントリ file のタイム・スタンプの値の10進表記文字列．
　　file が存在しないならば‘0’．


　freeof d:

　　ドライブ d の空き容量（バイト）の10進表記文字列．カレントのドライブは
　　‘@:’で指定することができます．


　strlen word

　　word の長さの10進表記文字列．


　{ command }

　　command をサブシェル（現在のシェルのコピー）で実行し，その終了ステータ
　　スが 0 ならば‘1’．そうでなければ‘0’．


　( E )

　　式 E の値．


　一次式が上記のどれにも当てはまらなければ，一次子があるべき位置にある単語
がそのまま一次式の値となります．


■ 演算式


　以下に各演算式について解説します．


　+ E

　　　式 E の値は数値でなければなりません．結果は E（数値）となります．


　- E

　　　式 E の値は数値でなければなりません．結果は E の符号を反転したもの（
　　　数値）となります．


　~ E

　　　式 E の値は数値でなければなりません．結果は E のビット・パターンをビッ
　　　ト毎に反転したもの（数値）となります．


　! E

　　　式 E の値は数値でなければなりません．結果は E が 0 ならば‘1’，そう
　　　でなければ‘0’となります．


　E1 * E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 と E2 とを
　　　乗じたもの（数値）となります．


　E1 / E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 を E2 で割っ
　　　たもの（数値）となります．E2 が 0 だとエラーとなります．


　E1 % E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 を E2 で割っ
　　　た余り（数値）となります．E2 が 0 だとエラーとなります．


　E1 + E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 と E2 とを
　　　加えたもの（数値）となります．


　E1 - E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 から E2 を
　　　減じたもの（数値）となります．


　E1 << E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 のビット・
　　　パターンを E2ビットだけMSB側にシフトしたもの（数値）となります．下位
　　　には 0 が詰められます．


　E1 >> E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 のビット・
　　　パターンを E2ビットだけLSB側にシフトしたもの（数値）となります．上位
　　　には元のMSB（符号ビット）が詰められます．


　E1 <= E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 が E2 より
　　　小さいか等しければ‘1’，そうでなければ‘0’となります．


　E1 >= E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 が E2 より
　　　大きいか等しければ‘1’，そうでなければ‘0’となります．


　E1 < E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 が E2 より
　　　小さければ‘1’，そうでなければ‘0’となります．


　E1 > E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 が E2 より
　　　大きければ‘1’，そうでなければ‘0’となります．


　E1 == E2
　E1 != E2

　　　式 E1 および E2 の値を文字列として比較します．式　E1 == E2 の結果は
　　　E1 と E2 が同一であれば‘1’，そうでなければ‘0’となります．式
　　　E1 != E2 の結果はその逆です．

　　　E1 と E2 が文字列として扱われることに注意してください．


　　　　　foo == foo


　　　の値は‘1’となります．E1 と E2 を数値とした場合，たとえば


　　　　　69 == 69


　　　の値も当然‘1’となりますし，


　　　　　66 + 3 == 69


　　　の値も‘1’となります．左項 66 + 3 は先に計算されて 69 という文字列
　　　になり，それと右項の文字列 69 とが比較されることになるからです．しか
　　　し，


　　　　　0x10 == 16


　　　では，一次子 0x10 は文字列としてそのまま評価されるため，これは右辺の
　　　文字列 16 とは一致せず，この式の値は‘0’となってしまいます．これを
　　　例えば


　　　　　0x10 + 0 == 16


　　　とすると，一次子 0x10 は演算子‘+’のために１度数値に変換され，それ
　　　に 0 を加えた結果は文字列‘16’に変換されるので，この式の値は‘1’と
　　　なります．


　E1 =~ E2
　E1 !~ E2

　　　式 E1 および E2 を文字列として比較します．== や != との違いは E2 を
　　　パターンとして，パターン比較を行うことです．式　E1 =~ E2 の結果は，
　　　文字列 E1 がパターン E2 にマッチすれば‘1’，そうでなければ‘0’とな
　　　ります．式　E1 !~ E2 の結果はその逆です．

　　　E2 が一次式（すなわち単語）であるならば，E2 の単語に対して単語毎の置
　　　換は行われません．


　E1 & E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 と E2 のビッ
　　　ト・パターンのビット毎の論理積（数値）となります．


　E1 ^ E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 と E2 のビッ
　　　ト・パターンのビット毎の排他的論理和（数値）となります．


　E1 | E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 と E2 のビッ
　　　ト・パターンのビット毎の論理和（数値）となります．


　E1 && E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 と E2 のど
　　　ちらも 0 でなければ‘1’，そうでなければ‘0’となります．この式では，
　　　まず式 E1 が評価され，その値が 0 でなければ式 E2 が評価されます．E1
　　　が 0 であれば式 E2 は評価されません．


　E1 || E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 と E2 のど
　　　ちらも 0 ならば‘0’，そうでなければ‘1’となります．この式では，ま
　　　ず式 E1 が評価され，その値が 0 ならば式 E2 が評価されます．E1 が 0
　　　でなければ式 E2 は評価されません．


　E1 ? E2 : E3

　　　式 E1 の値は数値でなければなりません．E1 が 0 でなければ式 E2 が評価
　　　され，この式の値は E2 となります．このとき式 E3 は評価されません．そ
　　　うでなければ式 E3 が評価され，この式の値は E3 となります．このとき式
　　　E2 は評価されません．


　E1 , E2

　　　式 E1 を評価してから式 E2 を評価します．結果は E2 となります．


■ 演算子の優先順位


　次の表は演算子の優先順位と結合方向をまとめたものです．


　　┌────┬────┬──────────────────────┐
　　│優先順位│結合方向│                     式                     │
　　├────┼────┼──────────────────────┤
　　│   高   │   ←   │   + E     - E     ~ E     ! E              │
　　│        │   →   │   E1 * E2   E1 / E2   E1 % E2              │
　　│   ↑   │   →   │   E1 + E2   E1 - E2                        │
　　│        │   →   │   E1 << E2  E1 >> E2                       │
　　│        │   →   │   E1 <= E2  E1 >= E2  E1 < E2   E1 > E2    │
　　│        │   →   │   E1 == E2  E1 != E2  E =~ pat  E !~ pat   │
　　│        │   →   │   E1 & E2                                  │
　　│        │   →   │   E1 ^ E2                                  │
　　│        │   →   │   E1 | E2                                  │
　　│        │   →   │   E1 && E2                                 │
　　│   ↓   │   →   │   E1 || E2                                 │
　　│        │   ←   │   E1 ? E2 : E3                             │
　　│   低   │   →   │   E1 , E2                                  │
　　└────┴────┴──────────────────────┘



■
■  組み込みコマンド
■


　FISHには以下のコマンドが組み込まれており，これらは仮想的なディレクトリ
‘~~’下に置かれています．

　組み込みコマンドを実行する際には，実行する直前にシェル変数 status に 0
がセットされ，その後，組み込みコマンド実行時にエラーがあったときにのみ，シェ
ル変数に 1 がセットされます．ですから，set status=5 あるいは @ status=5 を
実行後の status の値は 0 ではなく 5 です．また，exit 5 を実行後の status
の値も，やはり 5 です．



alias

　定義されているすべての別名とその意味を表示します．



alias <名前>

　別名 <名前> の定義を表示します．



alias <名前> <単語リスト>

　<名前> を <単語リスト>（コマンド）の別名として定義します．<名前> はどの
　ような綴りでも構いませんが，例外として，alias，unalias を別名として定義
　することはできません．また，‘\’を含む名前の別名は決して展開されません．



alloc

　FISH が定常的に確保している動的メモリの量と使用状況を表示します．



bind

　現在のキー・バインドを表示します．ただし self-insert と error は表示しま
　せん．



bind -a

　現在のすべてのキーのバインドを表示します．



bind <キー>
bind -1 <キー>
bind prefix-1 <キー>
bind -2 <キー>
bind prefix-2 <キー>

　<キー>，prefix-1 <キー>，prefix-2 <キー> にバインドされている機能を表示
　します．<キー> は１文字の引数です．制御文字を <キー> として指定するため
　に，引数 <キー> を '^D' のように２文字で表わすことができます．もちろん，
　もし可能ならば制御文字を直接引数に置いてもかまいません．



bind <キー> <機能>
bind -1 <キー> <機能>
bind prefix-1 <キー> <機能>
bind -2 <キー> <機能>
bind prefix-2 <キー> <機能>

　<キー>，prefix-1 <キー>，prefix-2 <キー> に <機能> をバインドします．
　<機能> については『行入力機構』を参照して下さい．



bind <キー> macro <文字列>
bind -1 <キー> macro <文字列>
bind prefix-1 <キー> macro <文字列>
bind -2 <キー> macro <文字列>
bind prefix-2 <キー> macro <文字列>

　<キー>，prefix-1 <キー>，prefix-2 <キー> に <文字列> をバインドします．
　このコマンドを実行した後は，<キー>（あるいは prefix-1 <キー>，prefix-2
　<キー>）を押すと，<文字列> があたかもユーザがタイプしたかのように入力さ
　れます．



breaksw

　現在の switch の endsw の直後に跳びます．現在の行の残りのコマンドは実行
　されます．ですから，


　　breaksw ; break


　は，現在の switch〜endsw を脱出した後，その外側の foreach または while
　のループも脱出します．



break

　現在の foreach / while の end の直後に跳び，ループを脱出します．現在の行
　の残りのコマンドは実行されます．ですから，


　　　break ; break


　は，現在のループを脱出した後，その外側のループも脱出します．



cd
chdir

　ユーザのホーム・ディレクトリに移動します．



cd +<N>
chdir +<N>

　ディレクトリ・スタックから先頭のディレクトリ（現在のカレント・ディレクト
　リ）を破棄し，<N>番目のディレクトリが先頭（カレント・ディレクトリ）とな
　るようにスタック全体を回転します．スタックの先頭（カレント・ディレクトリ）
　は 0番です．<N> は 1 以上でなければなりません．



cd +<N>.
chdir +<N>.

　ディレクトリ・スタックから先頭のディレクトリ（現在のカレント・ディレクト
　リ）を破棄し，<N>番目のディレクトリを抜き出してスタックの先頭（カレント・
　ディレクトリ）に積みます．スタックの先頭（カレント・ディレクトリ）は 0番
　です．<N> は 1 以上でなければなりません．



cd <名前>
chdir <名前>

　ディレクトリ <名前> に移動します．ディレクトリ <名前> が存在しない場合に
　はシェル変数 cdpath の各要素のディレクトリ下のディレクトリ <名前> につい
　て試します．そのどれもが存在しない場合には，シェル変数 <名前> の値のディ
　レクトリに移動します．それも存在しなければエラーとなります．



continue

　現在の foreach/while の end に跳び，foreach/while を継続します．現在の行
　の残りのコマンドは実行されます．ですから，


　　　continue ; echo 'Next'


　は，実際には 'Next' を表示した後に continue することになります．



dirs [ -l ] [ -v ]

　ディレクトリ・スタックの内容を表示します．左側がスタックの先頭であり，カ
　レント・ディレクトリを表わします．通常は，要素がユーザのホーム・ディレク
　トリ下のディレクトリである場合，ユーザのホーム・ディレクトリ部分は ~ と
　略記します．-l オプションを指定すると，どの場合にも完全パス名を表示しま
　す．-v オプションを指定すると，1行に１エレメントの形式でスタックの先頭か
　ら順に番号とともに表示します．スタックの先頭すなわちカレント・ディレクト
　リは 0番 であり，以下，1, 2, 3, ... と続きます．



echo [ -c ] [ -e ] [ -r ] [ -n ] [ -2 ] [ - ] <単語リスト>

　<単語リスト> を標準出力に出力します．-2 オプションを指定すると標準出力で
　はなく標準エラー出力に出力します．単語間には１文字のスペースを出力します．
　通常は最後に復帰改行を出力しますが，-c オプションを指定すると，単語の数
　が０個であるときには復帰改行を出力しません．-n オプションは常に復帰改行
　の出力を抑止します．

　-e オプションを指定すると，以下の文字エスケープ符号を使用することができ
　ます．


　　\\  文字‘\’
　　\a  ベル
　　\b  バックスペース
　　\c  最後の復帰改行を抑止する
　　\f  改頁
　　\n  復帰改行
　　\r  復帰
　　\t  水平タブ
　　\v  垂直タブ

　　\d
　　\dd
　　\ddd

　　　　8進表記の文字コード（d は‘0’から‘7’までのいずれかの文字）


　これ以外のシーケンスは，文字エスケープ符号とは見なされず，そのまま出力さ
　れます．

　-r オプションは -e オプションを取り消します．

　<単語リスト> の最初の単語がオプション引数と認められてしまうケースでは，
　<単語リスト> の直前に単語‘-’を置いて，それを回避してください．



eval <単語リスト>

　<単語リスト> をシェルの入力行として解析し，現在のシェルで実行します．た
　だし出力がパイプやファイルに切り替えられている場合にはサブシェルで実行さ
　れます．



exit [ <式> ]

　<式> の値をシェル変数 status にセットした上で，シェルの入力を強制的に EOF
　とします．<式> を省略した場合にはシェル変数 status の値は 0 となります．

　スクリプトをsourceしているときや関数を実行中は，その実行を終了することに
　なり，それ以外の場合にはシェルを終了することになります．

　シェルは終了する際，通常はシェル変数 status の値をシェルの終了ステータス
　とします．ですから，


　　　exit 5


　を実行すると status の値は 5 となり，シェルは終了ステータスを 5 として終
　了します．


　　　exit 5 ; echo bye bye


　では，exit 実行後に status は 5 となりますが，その後 echo を実行して
　status は 0 となりますので，シェルは終了ステータスを 0 として終了します．


　　　exit 5 ; goto label


　では，exit 実行後，ラベル label に跳びますので，シェルは終了しません．



functions

　定義されているすべての関数の内容を標準出力に出力します．



functions <名前>

　関数 <名前> の内容を標準出力に出力します．



glob <単語リスト>

　<単語リスト> を標準出力に出力します．単語間には NUL(0x00) を出力します．



goto <ラベル>

　<ラベル> に跳びます．現在の行の残りのコマンドは実行されます．ですから，


　　　goto foo ; goto bar


　は，ラベル foo に跳んだ後，ラベル bar に跳びます．シェルの入力が標準入力
　であるときには goto は実行できません．



hashstat

　ハッシュ表によるコマンド検索の成功度を表示します．



history [ -h ] [ -r ] [ <イベント数> ]

　保存されている履歴リストから最新の <イベント数> 個のイベントを，イベント
　番号および登録された時刻と共に表示します．<イベント数> を省略するとシェ
　ル変数 history の値がデフォルトとなります．-r オプションを指定すると新し
　い順に，そうでなければ古い順に表示します．-h オプションを指定するとイベ
　ント番号や登録された時刻をつけずにイベント本体のみを表示します．



history -x <N>[-<M>]

　履歴の N番（から M番まで）のイベントをイベント番号や登録時刻なしで標準出
　力に出力します．



logout

　ログイン・シェルを即座に終了します．



onintr

　^C が押されたときには実行を停止するようにします．シェルの入力が標準入力
　であるときには実行できません．



onintr -

　^C が押されても次の行からの実行を継続するようにします．^C 自体を禁止する
　ものではありませんので注意してください．シェルの入力が標準入力であるとき
　には実行できません．



onintr <ラベル>

　^C が押されたときに <ラベル> に跳ぶようにします．シェルの入力が標準入力
　であるときには実行できません．



popd

　ディレクトリ・スタックの先頭のディレクトリ（カレント・ディレクトリ）を捨
　て，新たに先頭となったディレクトリに移動します．



popd +<N>

　ディレクトリ・スタックから <N>番目のディレクトリを捨てます．スタックの先
　頭（カレント・ディレクトリ）は 0番です．<N> は 1 以上でなければなりませ
　ん．



printf [ -2 ] [ - ] <書式制御文字列> [ <単語> | <式> ] ...

　<書式制御文字列> による制御のもとで <単語> や <式> の値を変換して標準出
　力に出力します．-2 オプションを指定すると標準出力ではなく標準エラー出力
　に出力します．<書式制御文字列> がオプション引数と認められてしまうケース
　では，<書式制御文字列> の直前に単語‘-’を置いてそれを回避してください．

　<書式制御文字列> には次の２つの種類のオブジェクトが含まれます．


　　●変換指示

　　●その他の，普通の文字の並び


　変換指示は，続く引数（<単語> または <式>）を変換した文字列を出力します．
　続く引数の数と，それぞれが <単語> であるべきか <式> であるべきかは，<書
　式制御文字列> に含まれる変換指示の数と種類に依存します．<書式制御文字列>
　の変換指示以外の部分は，そのまま出力されます．

　変換指示は‘%’で始まって変換操作記号で終わります．‘%’と変換操作記号と
　の間には次に示す項目が次に示す順序で置くことができます．


　●　フラグ文字

　　　以下のフラグを任意の順序で任意の組み合わせで使用することができます．
　　　１つも使用しなくてもかまいません．


　　　-         左詰めとします．このフラグを使用しなければ右詰めとなります．

　　　0         右詰めのとき，フィールドの隙間を‘0’で埋めます．このフラ
　　　　　　　　グを使用しなければスペースで埋められます．

　　　　　　　　　　数値変換（d,i,u,o,x,X）においては，符号や接頭辞はフィー
　　　　　　　　ルドの左端に寄せて出力され，数値の上位の桁が‘0’で埋められ
　　　　　　　　ます．

　　　+         符号つき整数変換のとき，必ず‘-’か‘+’のどちらかの符号を
　　　　　　　　つけます．

　　　スペース  符号つき整数変換のとき，必ず符号‘-’かスペースのどちらか
　　　　　　　　をつけます．

　　　#         各変換操作ごとに特別な変換フォーマットを使用します．


　●　最小フィールド幅

　　　フィールドの幅，すなわち少なくとも出力する文字（バイト）数を10進表記
　　　の正整数で指示します．この表記は‘0’で始まるものであってはなりませ
　　　ん．その‘0’は 0フラグと見なされてしまうからです．

　　　　　最小フィールド幅として‘*’を記述することもできます．そうすると
　　　引数から <式> が１つ消費され，その <式> の値が最小フィールド幅となり
　　　ます．

　　　　　変換出力が最小フィールド幅よりも短い場合，変換出力は通常はその
　　　フィールドの右側に寄せて出力されます．このとき左側に生じる隙間部分に
　　　は通常はスペースが出力されます．0フラグを使用したときにはスペースの
　　　代わりに‘0’が出力されます．このとき，数値変換（d,i,u,o,x,X）におい
　　　ては，符号や接頭辞はフィールドの左端に寄せて出力され，数値の上位の桁
　　　が‘0’で埋められます．

　　　　　- フラグを使用したときには変換出力はフィールドの左側に寄せて出力
　　　され，このとき右側に生じる隙間部分にはスペースが出力されます．

　　　　　変換出力が最小フィールド文字幅よりも長い場合には変換出力がそのま
　　　ま出力されます．最小フィールド幅の指示は省略可能です．省略した場合の
　　　デフォルトは 0 です．


　●　精度

　　　‘.’（ピリオド）に続けて，精度を表わす数値を10進表記の正整数で指示
　　　します．ピリオドのみで，その後ろに数字が続いていない場合，精度は 0
　　　と見なされます．精度を指定した場合の動作は各変換操作ごとに異なります．


　変換操作記号には次のものがあります．


　　　d   符号つき10進変換．引数から <式> を１つ消費し，その <式> の値を符
　　　　　号つき整数として10進表記に変換して出力します．

　　　　　　　精度が指定されていなければ必要最小限の桁を変換します．精度が
　　　　　指定されているときには，少なくとも精度分の桁を変換します．

　　　　　　　値が負数ならば変換出力の先頭には符号‘-’がつきます．値が正
　　　　　数である場合，+ フラグがあるならば符号‘+’がつきます．+ フラグ
　　　　　がなくスペースフラグがあるならばスペースがつきます．どちらのフラ
　　　　　グもなければ何もつきません．# フラグは何の効果もありません．

　　　i   d と同じです．

　　　u   符号なし10進変換．引数から <式> を１つ消費し，その <式> の値を符
　　　　　号なし整数として10進表記に変換して出力します．

　　　　　　　精度が指定されていなければ必要最小限の桁を変換します．精度が
　　　　　指定されているときには，少なくとも精度分の桁を変換します．

　　　　　　　+，スペース，および # フラグは何の効果もありません．

　　　o   符号なし 8進変換．引数から <式> を１つ消費し，その <式> の値を符
　　　　　号なし整数として 8進表記に変換して出力します．

　　　　　　　精度が指定されていなければ必要最小限の桁を変換します．精度が
　　　　　指定されているときには，少なくとも精度分の桁を変換します．

　　　　　　　# フラグを使用すると最初に‘0’がつきます．+ および スペース
　　　　　フラグは何の効果もありません．

　　　x   符号なし16進変換．引数から <式> を１つ消費し，その <式> の値を符
　　　　　号なし整数として16進表記に変換して出力します．桁として 01234567
　　　　　89abcdef を用います．

　　　　　　　精度が指定されていなければ必要最小限の桁を変換します．精度が
　　　　　指定されているときには，少なくとも精度分の桁を変換します．

　　　　　　　# フラグを使用すると最初に‘0x’がつきます．+ および スペー
　　　　　スフラグは何の効果もありません．

　　　X   符号なし16進変換．引数から <式> を１つ消費し，その <式> の値を符
　　　　　号なし整数として16進表記に変換して出力します．桁として 01234567
　　　　　89ABCDEF を用います．

　　　　　　　精度が指定されていなければ必要最小限の桁を変換します．精度が
　　　　　指定されているときには，少なくとも精度分の桁を変換します．

　　　　　　　# フラグを使用すると最初に‘0X’がつきます．+ および スペー
　　　　　スフラグは何の効果もありません．

　　　c   <式> の値を１バイト文字コードとして，その文字を出力します．引数
　　　　　から <式> が１つ消費されます．

　　　　　　　精度は何の意味も持ちません．

　　　　　　　+，スペース，および # フラグは何の効果もありません．

　　　s   引数から <単語> を１つ消費し，その <単語> を文字列として出力しま
　　　　　す．

　　　　　　　精度が指定されていなければ <単語> 全体を出力します．精度が指
　　　　　定されているときには，その精度（バイト数）分の文字を出力します．
　　　　　ただし <単語> の長さが <精度> よりも小さければ終わりまでを出力し
　　　　　ます．

　　　　　　　+，スペース，および # フラグは何の効果もありません．

　　　%   文字‘%’を出力します．引数は１つも消費しません．

　　　　　　　精度は何の意味も持ちません．

　　　　　　　- フラグ，0 フラグ，および最小フィールド幅はこの変換に対して
　　　　　も例外なく有効です．たとえば %05% は 0000% となります．

　　　　　　　+，スペース，および # フラグは何の効果もありません．


　<書式制御文字列> 中の文字は以下のエスケープ文字で表記することができます．


　　\a  ベル
　　\b  バックスペース
　　\f  改頁
　　\n  復帰改行
　　\r  復帰
　　\t  水平タブ
　　\v  垂直タブ

　　\d
　　\dd
　　\ddd

　　　　8進表記の文字コード（d は‘0’から‘7’までのいずれかの文字）

　　\xd
　　\xdd
　　\xddd

　　　　16進表記の文字コード（d は‘0’から‘9’まで，‘A’から‘F’まで，
　　　　‘a’から‘f’までのいずれかの文字）


　‘\’に続くシーケンスが上記のどれにも当てはまらないならば，‘\’は無視さ
　れます．

　文字‘\’は printf の実行を開始するよりも前にFISHによって削除されること
　に注意してください．たとえば \n を printf に渡したいならば，\\n のよう
　に‘\’を‘\’でエスケープするか，または "\n"，'\n' のようにクオートしな
　ければなりません．ミスを減らすため，<書式制御文字列> 全体を常に‘"’また
　は‘'’の対でクオートするのが良いでしょう．



pushd

　ディレクトリ・スタックの先頭の２つのディレクトリを交換します．スタックの
　先頭の要素はカレント・ディレクトリですから，新たに先頭となったディレクト
　リに移動することになります．これは pushd +1. と同じです．



pushd +<N>

　ディレクトリ・スタック全体を，先頭に向かって <n>個分回転します．結果，
　<N>番目にあったディレクトリが先頭（カレント・ディレクトリ）となります．
　スタックの先頭（カレント・ディレクトリ）は 0番です．<N> は 1 以上でなけ
　ればなりません．



pushd +<N>.

　ディレクトリ・スタックから <N>番目のディレクトリを抜き出し，スタックの先
　頭（カレント・ディレクトリ）に積みます．スタックの先頭（カレント・ディレ
　クトリ）は 0番です．<N> は 1 以上でなければなりません．



pushd <名前>

　カレント・ディレクトリの完全パス名をディレクトリ・スタックにプッシュした
　後に，ディレクトリ <名前> に移動します．cd コマンド同様，ディレクトリ
　<名前> が存在しない場合にはシェル変数 cdpath の各要素のディレクトリ下の
　ディレクトリ <名前> について試します．そのどれもが存在しない場合には，シェ
　ル変数 <名前> の値のディレクトリに移動します．それも存在しなければエラー
　となります．



pwd [ -l ]

　カレント・ディレクトリを表示します．通常は，カレント・ディレクトリがユー
　ザのホーム・ディレクトリ下のディレクトリである場合，ユーザのホーム・ディ
　レクトリ部分は ~ と略記します．-l オプションを指定すると，どの場合にも完
　全パス名を表示します．



rehash

　コマンド検索ハッシュ表を更新します．



repeat <回数> <コマンド>

　<コマンド> を <回数> だけ繰り返し実行します．<回数> は符号なし10進表記整
　数です．<コマンド> は単一のコマンドもしくはサブシェルでなければならず，
　別名も効きません．<回数> が 0 ならば <コマンド> は実行されませんが，組み
　込みコマンド repeat に対する入出力切り替えは行われることに注意してくださ
　い．



set

　定義されているシェル変数をすべて表示します．変数の値は ( ) で囲って表示
　されます．ただし要素が１個ならば ( ) はつきません．



set <名前>
set <名前>=<単語>
set <名前>=(<単語リスト>)
set <名前>[<インデックス>]=<単語>

　最初の３つの形式はシェル変数 <名前> をセットします．シェル変数 <名前> の
　値は，最初の形式では１つの空単語，２番目の形式では１つの <単語>，３番目
　の形式では <単語リスト> となります．<名前> は31バイト以下の単語です．
　<名前> の綴りは，ASCII英数字，‘_’（アンダースコア），シフトJISコードの
　組み合わせでなければならず，さらに，<名前> の先頭の文字は ASCII数字であっ
　てはなりません．

　最後の形式はシェル変数 <名前> の <インデックス> 番目の要素を <単語> とし
　ます．この形式のセットを行うには，<インデックス> 以上の数の要素を持つシェ
　ル変数 <名前> が既にセットされている必要があります．

　　　いずれの形式においても，‘=’の前後には空白文字（スペース，復帰，改
　行，改頁，水平タブ，垂直タブ）があってもなくてもかまいません．

　　　これらの引数は，単一の set コマンド内で複数のセットを行うするために
　繰り返すことができます．



setenv

　定義されている環境変数をすべて表示します．



setenv <名前> [ <単語> ]

　環境変数 <名前> を定義します．値は <単語> になります．<単語> がなければ
　値は空文字列になります．



shift

　シェル変数 argv の要素を左に１つシフトします．最初の要素は破棄されます．



shift <名前>

　シェル変数 <名前> の要素を左に１つシフトします．最初の要素は破棄されます．



source [ -h ] <ファイル名>

　スクリプト・ファイル <ファイル名> を現在のシェルで実行します．ただし出力
　がパイプやファイルに切り替えられている場合にはサブシェルで実行されます．
　-h オプションを指定するとコマンドを実行せず，スクリプトからの入力行を履
　歴リストに登録します．<ファイル名> として '-' を指定すると標準入力から読
　み取ります．たとえば


　　　make -n | source -


　は make が実行するであろうコマンドを make ではなくFISHで実行します．また，


　　　make -n | source -h -


　とすれば make が実行するであろうコマンドが履歴リストに登録されます．それ
　を


　　　history -x <N>-<M> | source -


　で実行したり，あるいは行編集機能 up-history を用いて編集してから実行する
　ことができます．



srand [ <種> ]

　乱数 $, の新しい系列の種として <種> を使用します．<種> は 0以上 32767以
　下の符号なし10進表記整数です．<種> を省略すると，マシン起動からの経過時
　間が種として使用されます．最初の種は 1 です．



time

　現在のFISHを起動してから経過した時間を表示します．



time <コマンド>

　<コマンド> を実行し，コマンドが消費した時間を表示します．<コマンド> は単
　一のコマンドでなければならず，別名も効きません．



unalias <パターン> ...

　<パターン> にマッチする別名をすべて取り消します．<パターン> にマッチする
　別名が定義されていなくてもエラーにはなりません．

　　　単一の unalias コマンドで複数の取り消しを行うために複数の <パターン>
　を並べることができます．



undefun <パターン> ...

　<パターン> にマッチする名前の関数をすべて削除します．<パターン> にマッチ
　する名前の関数が定義されていなくてもエラーにはなりません．

　　　単一の undefun コマンドで複数の削除を行うために複数の <パターン> を
　並べることができます．



unhash

　コマンド検索ハッシュ表を使用しないようにします．



unset <パターン> ...

　<パターン> にマッチする名前のシェル変数をすべて削除します．<パターン> に
　マッチする名前のシェル変数がセットされていなくてもエラーにはなりません．

　　　単一の unset コマンドで複数の削除を行うために複数の <パターン> を並
　べることができます．



unsetenv <名前> ...

　環境変数 <名前> を削除します．環境変数 <名前> がセットされていなくてもエ
　ラーにはなりません．

　　　単一の unsetenv コマンドで複数の削除を行うために複数の <名前> を並べ
　ることができます．



which <コマンド名>
which -o <コマンド名>
which -O <コマンド名>

　コマンド <コマンド名> を検索して，その実体を表示します．-o オプションを
　指定すると別名は除外して検索します．-O オプションを指定するとさらに関数
　や組み込みコマンドも除外してディスク・ファイルのみを検索します．

　　　いずれにしても，シェル変数 noalias がセットされているときには別名は
　除外します．



@

　set と同様に，定義されているシェル変数をすべて表示します．



@ <名前> = <式>

　シェル変数 <名前> をセットします．値の単語数は１つであり，それは <式> の
　値となります．

　　　<式> の値は数値でなくてはなりません．

　　　代入演算子の前後には空白文字（スペース，復帰，改行，改頁，水平タブ，
　垂直タブ）があってもなくてもかまいません．



@ <名前> *= <式>
@ <名前> /= <式>
@ <名前> %= <式>
@ <名前> += <式>
@ <名前> -= <式>
@ <名前> <<= <式>
@ <名前> >>= <式>
@ <名前> &= <式>
@ <名前> ^= <式>
@ <名前> |= <式>

　シェル変数 <名前> の最初の要素の値と <式> の値とを言語Ｃと同様に演算し，
　結果をシェル変数 <名前> にセットします．シェル変数 <名前> の要素数は１つ
　となります．

　　　少なくとも１つの要素を持つシェル変数 <名前> がセットされていなければ
　なりません．

　　　シェル変数 <名前> の最初の要素の値と <式> の値は数値でなくてはなりま
　せん．

　　　代入演算子の前後には空白文字（スペース，復帰，改行，改頁，水平タブ，
　垂直タブ）があってもなくてもかまいません．



@ <名前>[<インデックス>] = <式>
@ <名前>[<インデックス>] *= <式>
@ <名前>[<インデックス>] /= <式>
@ <名前>[<インデックス>] %= <式>
@ <名前>[<インデックス>] += <式>
@ <名前>[<インデックス>] -= <式>
@ <名前>[<インデックス>] <<= <式>
@ <名前>[<インデックス>] >>= <式>
@ <名前>[<インデックス>] &= <式>
@ <名前>[<インデックス>] ^= <式>
@ <名前>[<インデックス>] |= <式>

　シェル変数 <名前> の <インデックス> 番目の要素の値と <式> の値とを言語Ｃ
　と同様に演算し，結果をシェル変数 <名前> の <インデックス> 番目の要素にセッ
　トします．

　　　代入演算子の前後には空白文字（スペース，復帰，改行，改頁，水平タブ，
　垂直タブ）があってもなくてもかまいません．



@ <名前> ++
@ <名前> --

　シェル変数 <名前> の最初の要素の値に 1 を加算／減算した結果をシェル変数
　<名前> にセットします．シェル変数 <名前> の要素数は１つとなります．

　　　演算子の前には空白文字（スペース，復帰，改行，改頁，水平タブ，垂直タ
　ブ）があってもなくてもかまいません．



@ <名前>[<インデックス>] ++
@ <名前>[<インデックス>] --

　シェル変数 <名前> の <インデックス> 番目の要素の値に 1 を加算／減算した
　結果をシェル変数 <名前> の <インデックス> 番目の要素にセットします．

　　　演算子の前には空白文字（スペース，復帰，改行，改頁，水平タブ，垂直タ
　ブ）があってもなくてもかまいません．



■
■  行入力機構
■


　FISHは編集機能を持つ独自の行入力機構を持っています．FISHがインタラクティ
ブ・モードであって，かつシェル変数 usegets がセットされていなければ，独自
の行入力機構が働きます．

　FISHの行入力機構では，端末から入力されるすべてのコードに「機能」がバイン
ドされています．各コードの機能は，組み込みコマンド bind で自由に変更するこ
とができます．

　以下に，各機能について解説します．


abort

　　行入力を中止し，^C 処理に跳びます．


accept-line

　　入力した行をシェルに渡します．


backward-char

　　カーソルを１文字後方に移動します．


backward-word

　　カーソルを１語後方に移動します．


beginning-of-line

　　カーソルを行の先頭に移動します．


clear-and-redraw

　　画面をクリアしてから行を書き直します．


complete

　　現在のカーソル位置までの文字列を補い，ユーザ名／ファイル（ディレクトリ・
　　エントリ）名／組み込みコマンド名を完成させます．

　　補完とは，入力済みの文字列から特定できる残りの綴りを，あたかもそれをユー
　　ザがタイプしたかのように自動的に追加することです．

　　カーソルよりも左に以下に示す文字がある場合には，その次の文字からカーソ
　　ル位置までが補完させる文字列となります．


　　　　空白文字（スペース，復帰，改行，改頁，水平タブ，垂直タブ）
　　　　"   '   `   ^   &   (   )   |   ;   <   >


　　補完させる文字列中に文字‘\’があっても，特別な意味を認めず，単なる文
　　字とします．

　　補完させる文字列が‘~~/’で始まっているならば組み込みコマンド名を補完
　　します．そうではなく，補完させる文字列が‘~’で始まっていて，且‘/’を
　　含んでいないならばユーザ名を補完します．それ以外の場合はディスク上のファ
　　イル（ディレクトリ・エントリ）名を補完します．ただし，エントリ‘.’お
　　よび‘..’とボリューム・ラベルは常に候補対象から除外されます．

　　ファイル名を補完するとき，通常はファイル名の大文字と小文字を区別します
　　が，シェル変数 cifilec がセットされていればFISHは検索されたファイル名
　　の再チェックを省きますので，ファイル名の大文字と小文字は区別されなくな
　　ります．ただし，ファイル名の大文字と小文字を区別するシステム上では，シェ
　　ル変数 cifilec をセットしてもファイル名の大文字と小文字は区別されます．

　　パスの途中のディレクトリ名を‘\’で区切ったファイル名を補完することは
　　できません。ファイル名補完では，ディレクトリの区切りは‘/’のみが認め
　　られます．

　　補完できる名前の候補が１つもなければ，通常，ベルが鳴ります．入力済みの
　　文字列にマッチする名前が２つ以上ある場合には，いずれにしても特定できる
　　綴りのみを補って，通常はベルを鳴らします．

　　シェル変数 recexact がセットされているときには，完全に一致する名前が１
　　つあれば，さらに長い候補があってもそれ以上は補完しません．この場合には
　　通常はベルは鳴りません．

　　補完の際にベルを鳴らす条件は，シェル変数 matchbeep と nobeep とで制御
　　することができます．

　　無視したいサフィックスのリストをシェル変数 fignore にセットしておくこ
　　とにより、特定のサフィックスを持ったファイルを候補対象から除外すること
　　ができます．ただし，与えられた文字列から完成できる唯一の名前が fignore
　　で除外されているものでしか特定できない場合には，これらのサフィックスを
　　無視しません．


copy-prev-word

　　カーソルの直前の単語をカーソル位置にコピーします．


copy-region

　　マークとカーソルの間の範囲をカット・バッファにコピーします．


delete-backward-char

　　カーソルの後方の１文字を削除します．


delete-forward-char

　　カーソル下の１文字を削除します．


down-history

　　編集行の先頭からカーソル位置までの部分が一致する行を履歴リストから降順
　　に検索します．


downcase-char

　　カーソル下の１文字の ASCII 大文字を小文字に変換します．


downcase-region

　　マークとカーソルの間の範囲の ASCII 大文字を小文字に変換します．


downcase-word

　　カーソル位置から単語の終わりまでの範囲の ASCII 大文字を小文字に変換し
　　ます．


end-of-line

　　カーソルを行末に移動します．


eof

　　EOF を入力します．


error

　　エラーとします．prefix-1，prefix-2，qouted-insert 等はキャンセルされま
　　す．また，シェル変数 nobeep がセットされていない場合にはベルが鳴ります．


exchange-point-and-mark

　　マーク位置とカーソル位置を交換します．


forward-char

　　カーソルを１文字前方に移動します．


forward-word

　　カーソルを１語前方に移動します．


kill-backward-word

　　後方の１語を削除してカット・バッファにコピーします．


kill-forward-word

　　前方の１語を削除してカット・バッファにコピーします．


kill-region

　　マークとカーソルの間の範囲を削除してカット・バッファにコピーします．


kill-to-bol

　　行の先頭からカーソルの直前までの範囲を削除してカット・バッファにコピー
　　します．


kill-to-eol

　　カーソル位置から行末までの範囲を削除してカット・バッファにコピーします．


kill-whole-line

　　現在の入力行をまるごと削除してカット・バッファにコピーします．


list

　　現在の状態での，機能 complete の候補を文字コード順にソートして表示しま
　　す．ここではシェル変数 fignore は効きません．ディレクトリは‘/’つきで
　　表示されます．

　　この機能は，ユーザ，ファイル，組み込みコマンドの一覧を見たいときにも便
　　利です．


prefix-1

　　prefix-1 シーケンスを導きます．たとえば


　　　　bind ^[ prefix-1
　　　　bind -1 ^L clear-and-redraw


　　と設定すると，ESC ^L の２ストロークで，clear-and-redraw 機能が働くこと
　　になります．


prefix-2

　　prefix-2 シーケンスを導きます．たとえば


　　　　bind ^X prefix-2
　　　　bind -2 ^L downcase-region


　　と設定すると，^X ^L の２ストロークで，downcase-region 機能が働くことに
　　なります．


quoted-insert

　　次に入力されるキャラクタをエスケープし，通常の文字として行に挿入します．


redraw

　　一旦改行し，行を書き直します．


search-character

　　次に入力されるキャラクタを，カーソルの次の位置から行末まで検索し，もし
　　見つかればカーソルをそこに移動します．見つからなかったならば，行の先頭
　　から再び検索します．


self-insert

　　自分自身を通常の文字として行に挿入します．


set-mark

　　カーソル位置をマークします．


transpose-chars

　　カーソル下の文字と後方の文字とを交換します．


transpose-words

　　カーソル下の単語と後方の単語とを交換します．


up-history

　　編集行の先頭からカーソル位置までの部分が一致する行を履歴リストから昇順
　　に検索します．


upcase-char

　　カーソル下の１文字の ASCII 小文字を大文字に変換します．


upcase-region

　　マークとカーソルの間の範囲の ASCII 小文字を大文字に変換します．


upcase-word

　　カーソル位置から単語の終わりまでの範囲の ASCII 小文字を大文字に変換し
　　ます．


yank

　　カット・バッファの内容をカーソル位置に挿入します．


　「単語」を単位とする機能ではFISHの行解析部と同じ字句解析を行って単語を分
けます．

　FISH起動時には，各入力コードには次の機能がバインドされています．


　　　　　^C                      abort
　　　　　^D                      eof
　　　　　^H                      del-back-char
　　　　　^M                      accept-line
　　　　　その他の単一コード      self-insert
　　　　　prefix-1下の各コード    error
　　　　　prefix-2下の各コード    error


　各入力コードには，上記の機能の他，「マクロ」をバインドすることができます．
たとえば，


　　bind ^[ prefix-1
　　bind -1 . macro 。


とすると，ESC . の２ストロークで全角の「。」を行に挿入することができます．
また，


　　bind ^U upcase-char
　　bind ^[ prefix-1
　　bind -1 l downcase-word
　　bind -1 c macro '^U^[l'
　　#  ただし '' の中の ^U と ^[ は，制御コードを直接
　　#  記述する．


とすると，ESC c の２ストロークで単語をキャピタライズすることができます．



■
■  特別なシェル変数
■


FISH_AUTHOR

　FISHの作者の氏名がセットされています．


FISH_COPYRIGHT

　FISHの版権告示がセットされています．


FISH_VERSION

　FISHのバージョン番号がセットされています．
　$@FISH_VERSION[1] はメジャー番号，
　$@FISH_VERSION[2] はマイナー番号，
　$@FISH_VERSION[3] はパッチレベルを示します．


addsuffix

　セットしておくと，行編集機能 complete によって名前が完全に完成したとき，
　その名前がディレクトリを示すものならば‘/’が，それ以外の場合には‘ ’
　（スペース）が名前の後ろに自動的に付加されるようになります．

　addsuffix=exact では，名前が完成した時点ではこの機能は働かず，完成してい
　る名前に対してさらに行編集機能 complete を行ったときに働くようになります．


argv

　FISHに与えられたフラグ以外の引数がセットされています．関数実行中は関数
　に与えられた引数がセットされています．


autolist

　セットしておくと，行編集機能 complete を働かせたところ候補が複数あって，
　かつそれらに共通部分が１文字もないとき，自動的に行編集機能 list が働いて
　候補のリストを表示します．


batshell

　拡張子が‘.BAT’であるコマンド・ファイルを実行するために exec するシェル
　のパス名．初期値は $%SYSROOT/bin/COMMAND.X です．


cdpath

　ディレクトリ移動の代替パスのリスト．


ciglob

　セットしておくと，ファイル名展開時にファイル名の大文字と小文字を区別しま
　せん．


cifilec

　セットしておくと，行編集機能 complete と list でファイル名の大文字と小文
　字を区別しません．ただし，ファイル名の大文字と小文字を区別するシステム上
　では，補完するパスの途中のディレクトリ名の大文字と小文字は必ず区別されま
　す．


cwd

　カレントの作業ディレクトリの完全パス名がFISHによって自動的にセットされま
　す．ディレクトリの区切り文字は‘/’です．なお，FISHはシェル変数 cwd をセッ
　トすると同時に，カレントの作業ディレクトリの完全パス名を環境変数 PWD に
　もセットします．環境変数 PWD ではディレクトリの区切り文字は‘\’です．


echo

　セットしておくと，コマンドを実行前に表示します．


envmargin

　子プロセスに渡す環境変数エリアに用意する余白のバイト数（10進表記）．


fignore

　行編集機能 complete で無視するサフィックスのリスト．


forceio

　セットしておくと，入出力切り替え先デバイスの入力ステータス／出力ステータ
　スを無視します．


gid

　ユーザのグループid．FISH起動時に，ファイル $SYSROOT/etc/passwd にしたがっ
　て初期設定されます．


histchars

　２つの履歴置換文字．シフトJIS文字も使用することができます．セットされて
　いないならば履歴置換文字は‘!’と‘^’となります．


history

　履歴イベントの，それが最後に参照されてからの保存期間（10進表記）．


home

　ユーザのホーム・ディレクトリのパス名．組み込みコマンド cd, chdir, dirs,
　popd, pushd, pwd，ディレクトリ置換，ファイル名完成機能等に使用されます．
　FISH起動時に環境変数 HOME の値の‘\’を‘/’に変えたパス名がセットされま
　す．シェル変数 home を再設定すると環境変数 HOME も自動的に再設定されます．
　その際には，シェル変数 home の値の‘/’は‘\’に変換されます．


hugearg

　コマンドへの引数が255バイトを越えたときの対処．

　set hugearg=force としておくと，強引にコマンドを起動します．

　set hugearg=indirect としておくと，引数を一時ファイルに書き込み，コマン
　ドには引数として‘-+-+-<ファイル名>’を渡します．<ファイル名> のディレク
　トリは‘\’で区切られています．

　set hugearg=(indirect <文字列>) としておくと，‘-+-+-’の代わりに <文字
　列> を使います．

　以上のどれにも当てはまらない場合には，コマンドをロードして HUPAIR適合コ
　マンドであるかどうかを調べ，HUPAIR適合コマンドでないならば，FISHはコマン
　ドを起動せず，エラーとします．


ignoreeof

　セットしておくと，端末からの EOF を無視し，EOF ではシェルを終了しないよ
　うにします．


matchbeep

　行編集機能 complete でベルを鳴らす条件を設定します．

　この変数がセットされていなければ，一致する候補が１つもない場合や一致する
　候補が複数ある場合，また，シェル変数 recexact がセットされているときに完
　全に一致する名前が１つあるけれどもさらに長い候補がある場合にベルが鳴りま
　す．

　matchbeep=nomatch としておくと，一致する候補が１つもなかった場合にのみベ
　ルが鳴ります．

　matchbeep=ambiguous としておくと，それに加えて複数の候補がある場合にもま
　たベルが鳴ります．

　matchbeep=notunique としておくと，それに加えて，シェル変数 recexact がセッ
　トしているときにおいて完全に一致する名前が１つあるけれどもさらに長い候補
　もあるという場合にもベルが鳴ります．

　シェル変数 matchbeep の設定がこれら以外であると，補完時にはどの場合にも
　ベルは鳴りません．

　なお，シェル変数 nobeep をセットしておくと，ベルはシェル変数 matchbeep
　の設定によらず決して鳴りません．


noalias

　セットしておくと別名置換しません．


nobeep

　セットしておくと，行編集中にエラーがあったり行編集機能 complete での補完
　が不完全であった場合にも決してベルを鳴らしません．


noclobber

　セットしておくと，すでに存在しているファイルに出力を切り替えたとき，およ
　び，存在しないファイルに対して出力を追加モードで切り替えたときにエラーと
　なります．


noglob

　セットしておくと，組み合わせ展開，ディレクトリ置換，ファイル名展開を行い
　ません．


nonomatch

　セットしておくと，ファイル名展開文字に一致するファイルがなかった場合，エ
　ラーとはせず，文字を展開せずに保存します．


notexportpath

　シェル変数 path をセットしたときに環境変数 path にエクスポートしないパス
　のパターンのリスト．


path

　コマンドのパスのリスト．FISH起動時に環境変数 path の値で初期設定されます．
　さらに，環境変数 path を再設定したとき自動的にシェル変数 path も再設
　定されます．環境変数 path からシェル変数 path へのインポートの際には，
　‘\’は‘/’に変換され，‘~~’と‘.’が先頭に追加されます．シェル変数
　path を再設定すると環境変数 path もまた自動的に再設定されます．その際に
　は‘/’は‘\’に変換され，‘~~’と‘.’は無視されます．


prompt

　主プロンプトの文字列．FISHがスクリプト・モードでなければ値を '% ' として
　初期セットされます．FISHがスクリプト・モードである場合には初期セットされ
　ません．

　以下のメタ・シーケンスを使用することができます．


　　%[-][0][<最小フィールド幅>]<変換操作記号>
　　  |  |
　　  |  |___ 右詰めのとき，左側には'0'を詰める
　　  |
　　  |___ 左詰め


　　　<最小フィールド幅>

　　　　少なくとも出力する文字（バイト）数を10進整数表記で示す．


　　　<変換操作記号>

　　　　?    シェル変数 status の値（10進表現）
　　　　!    カレント履歴イベント番号
　　　　p    カレント・ディレクトリ（~ による略記）
　　　　l    カレント・ディレクトリ（完全パス）
　　　　y    年（最小幅が4未満のときは下2桁のみ）
　　　　m    月
　　　　a    月の英語名の略記（Jan〜Dec）
　　　　d    日
　　　　h    曜日の英語名の略記（Sun〜Sat）
　　　　s    日本語での曜日（日〜土）
　　　　H    時
　　　　M    分
　　　　S    秒


　　%n   復帰改行

　　%%   文字‘%’


　この変数は将来廃止され，特別な関数 prompt がその代わりとなることでしょう．


prompt2

　副プロンプト（if文や switch文などのコンディションにより実行されない行の
　入力を促すとき，while文や foreach文などのループの中の行の入力を促すとき，
　および関数定義の際に出力するプロンプト）の文字列．FISHがスクリプト・モー
　ドでなければ値を '? ' として初期セットされます．FISHがスクリプト・モード
　である場合には初期セットされません．

　シェル変数 prompt と同じシーケンスを使用することができます．

　この変数は将来廃止され，特別な関数 prompt2 あるいは prompt がその代わり
　となることでしょう．


recexact

　セットしておくと，行編集機能 complete において候補の中に完全に一致するも
　のがある場合には名前は完全に完成しているものとし，もしそれよりもさらに長
　い別の候補があっても無視します．ただし候補の表示には影響しません．


savehist

　ログアウト時に保存する履歴イベント数（10進表記）．


shell

　既定のシェルのパス名．実行シェルが指定されていないシェル・スクリプトを実
　行するときにはこの変数に設定されているプログラムを起動します．初期値は
　$%SYSROOT/bin/fish.x です．


shlvl

　シェルの深さ（10進表記）．FISH起動時に環境変数 SHLVL の値に 1 を加えた値
　がセットされます．環境変数 SHLVL が定義されていない場合や値が無効である
　場合にはシェル変数 shlvl の値は 1 となります．FISHはシェル変数 shlvl を
　初期化した後，環境変数 SHLVL をシェル変数 shlvl と同じ値に再設定します．
　またシェル変数 shlvl を再設定すると環境変数 SHLVL も自動的に同じ値に再設
　定されます．


status

　コマンドの終了ステータス（10進表記）がFISHによって自動的にセットされます．
　コマンドの実行を ^C で中断したときや行編集機能 abort が働いたときには
　512 がセットされます．


temp

　FISHが一時ファイルを作成するディレクトリのパス名．FISH起動時に環境変数
　temp の値で初期設定されます．その際，‘\’は‘/’に変換されます．また，
　このシェル変数 temp を再設定すると環境変数 temp も自動的に再設定されます．
　その際には‘/’は‘\’に変換されます．


term

　ユーザの使用している端末名．FISH起動時に環境変数 TERM の値で初期設定され
　ます．また，このシェル変数 term を再設定すると環境変数 TERM も自動的に再
　設定されます．

　現在は無視しており，効力はありません．


time

　（組み込みコマンド以外の）コマンド実行後にコマンド経過時間を表示しない最
　大の実行時間（10進表記の秒数）．


usegets

　セットしておくと，独自の行入力機構の代わりに DOSファンクション gets で行
　入力を行います．このときには行編集機能は利用できず，EOF も入力できません．


uid

　ユーザのユーザid．FISH起動時に，ファイル $SYSROOT/etc/passwd にしたがっ
　て初期設定されます．


user

　ユーザのログイン名．FISH起動時に環境変数 USER（設定されていなければ，環
　境変数 LOGNAME）の値で初期設定されます．このシェル変数 user を再設定する
　と環境変数 USER も自動的に再設定されます．


verbose

　セットしておくと，行を入力する度に履歴置換後の行を表示します．



■
■  特別な環境変数
■


HOME

　FISH起動時，FISHがシェル変数 home を初期化するために参照します．シェル変
　数 home が再設定されたときには自動的に再設定されます．


LOGNAME

　FISH起動時，環境変数 USER が存在していなければ，FISHがシェル変数 user を
　初期化するために参照します．


PWD

　カレントの作業ディレクトリの完全パス名がFISHによって自動的にセットされま
　す．ディレクトリの区切り文字は‘\’です．環境変数 PWD のセットは，シェル
　変数 cwd のセットと同時に行われるほか，FISH外部のコマンドを起動する直前
　にもまたセットされます．


SHLVL

　シェルの深さ（10進表記）．FISH起動時，FISHは自分自身の環境変数 SHLVL を
　インクリメントします．環境変数 SHLVL が定義されていない場合や値が無効で
　ある場合には 1 に設定されます．この変数は親シェルから子シェルにシェルの
　深さを通知するために用いられます．FISHはシェル変数 shlvl を初期設定する
　ために環境変数 SHLVL を参照します．シェル変数 shlvl が再設定されたときに
　は自動的に同じ値に再設定されます．


SYSROOT

　システムのルート・ディレクトリを示しています．例えばファイル /etc/passwd
　の位置は，


　　　  $%SYSROOT  ファイル /etc/passwd のパス
　　　----------------------------------------
　　　   未定義       /etc/passwd
　　　   空           /etc/passwd
　　　   /            /etc/passwd
　　　   /ita         /ita/etc/passwd
　　　   C:           C:/etc/passwd
　　　   C:/          C:/etc/passwd
　　　   C:/ita       C:/ita/etc/passwd


　のように制御されます．また，シェル変数 batshell および shell の初期値も
　この変数の制御を受けます．

　※ この変数はユーザが変更してはなりません．


TERM

　FISH起動時，FISHがシェル変数 term を初期化するために参照します．シェル変
　数 term が再設定されたときには自動的に再設定されます．


USER

　FISH起動時，FISHがシェル変数 user を初期化するために参照します．シェル変
　数 user が再設定されたときには自動的に再設定されます．


path

　FISH起動時，FISHがシェル変数 path を初期化するために参照します．シェル変
　数 path が再設定されたときには自動的に再設定されます．この環境変数が再設
　定されたときにはシェル変数 path が自動的に再設定されます．


temp

　FISH起動時，FISHがシェル変数 temp を初期化するために参照します．シェル変
　数 temp が再設定されたときには自動的に再設定されます．



■
■  関連ファイル
■


$%SYSROOT/bin/COMMAND.X

　コマンド・ファイル．拡張子が .BAT であるスクリプト用の標準のシェル．


$%SYSROOT/bin/fish.x

　コマンド・ファイル．#$ または #! で始まるスクリプト用の標準のシェル．


$%SYSROOT/etc/passwd

　システム・ファイル．他ユーザのホーム・ディレクトリを得るために参照されま
　す．


$%SYSROOT/etc/fishrc

　システム環境ファイル．もしあれば，FISH起動時に最初に source されます．た
　だしFISHに対してオプション引数 -f が指定されている場合には source されま
　せん．


~/%fishrc

　個人環境ファイル．もしあれば，FISH起動時に $%SYSROOT/etc/fishrc の後に
　source されます．ただしFISHに対してオプション引数 -f が指定されている場
　合には source されません．


~/%history

　個人環境ファイル．もしあれば，FISH起動時に ~/%fishrc や ~/%login を
　source した後に source -h します．ただしFISHに対してオプション引数 -f が
　指定されている場合には source -h されません．

　FISHがログイン・シェルであるとき，シェル変数 savehist がセットされている
　ならば，~/%logout を source した後に $savehist[1] が示す行数分の最新の履
　歴イベントをセーブします．


~/%login

　個人環境ファイル．FISHがログイン・シェルであるとき，もしあればFISH起動時
　に ~/%fishrc の後に source されます．


~/%logout

　個人環境ファイル．FISHがログイン・シェルであるとき，もしあればFISH終了時
　に source されます．






